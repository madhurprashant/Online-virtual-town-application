{"files":{"/Users/madhur/Downloads/hw3-handout final/src/lib/CoveyTownController.ts":{"language":"typescript","mutants":[{"id":"1","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"src/lib/CoveyTownController.ts(125,61): error TS2345: Argument of type 'ServerConversationArea | undefined' is not assignable to parameter of type 'ServerConversationArea'.\n  Type 'undefined' is not assignable to type 'ServerConversationArea'.\n","status":"CompileError","estimatedNetTime":15,"hitCount":8,"static":false,"coveredBy":["3","7","8","14","16","17","38","39"],"location":{"end":{"column":21,"line":124},"start":{"column":9,"line":124}}},{"id":"0","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"src/lib/CoveyTownController.ts(125,61): error TS2345: Argument of type 'ServerConversationArea | undefined' is not assignable to parameter of type 'ServerConversationArea'.\n  Type 'undefined' is not assignable to type 'ServerConversationArea'.\n","status":"CompileError","estimatedNetTime":15,"hitCount":8,"static":false,"coveredBy":["3","7","8","14","16","17","38","39"],"location":{"end":{"column":21,"line":124},"start":{"column":9,"line":124}}},{"id":"8","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"src/lib/CoveyTownController.ts(150,55): error TS2345: Argument of type 'ServerConversationArea | undefined' is not assignable to parameter of type 'ServerConversationArea'.\n  Type 'undefined' is not assignable to type 'ServerConversationArea'.\nsrc/lib/CoveyTownController.ts(153,9): error TS2532: Object is possibly 'undefined'.\nsrc/lib/CoveyTownController.ts(154,80): error TS2345: Argument of type 'ServerConversationArea | undefined' is not assignable to parameter of type 'ServerConversationArea'.\n  Type 'undefined' is not assignable to type 'ServerConversationArea'.\n","status":"CompileError","estimatedNetTime":61,"hitCount":55,"static":false,"coveredBy":["2","6","13","18","20","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38"],"location":{"end":{"column":42,"line":148},"start":{"column":9,"line":148}}},{"id":"11","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"src/lib/CoveyTownController.ts(150,55): error TS2345: Argument of type 'ServerConversationArea | undefined' is not assignable to parameter of type 'ServerConversationArea'.\n  Type 'undefined' is not assignable to type 'ServerConversationArea'.\n","status":"CompileError","estimatedNetTime":52,"hitCount":40,"static":false,"coveredBy":["21","22","24","25","26","27","28","29","30","31","33","34","35","36","37","38"],"location":{"end":{"column":27,"line":149},"start":{"column":11,"line":149}}},{"id":"2","mutatorName":"BlockStatement","replacement":"{}","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: 1\nReceived: 2\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:1944:45\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":1,"hitCount":1,"static":false,"testsCompleted":1,"killedBy":["38"],"coveredBy":["38"],"location":{"end":{"column":6,"line":126},"start":{"column":23,"line":124}}},{"id":"5","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"Error: expect(received).toEqual(expected) // deep equality\n\nExpected: \"newConversationArea1 Label\"\nReceived: undefined\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:381:52\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":55,"hitCount":74,"static":false,"testsCompleted":18,"killedBy":["21"],"coveredBy":["21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38"],"location":{"end":{"column":56,"line":141},"start":{"column":15,"line":141}}},{"id":"7","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"Error: expect(jest.fn()).toHaveBeenCalledTimes(expected)\n\nExpected number of calls: 2\nReceived number of calls: 3\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:1808:54\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":61,"hitCount":55,"static":false,"testsCompleted":23,"killedBy":["37"],"coveredBy":["2","6","13","18","20","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38"],"location":{"end":{"column":42,"line":148},"start":{"column":9,"line":148}}},{"id":"12","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"src/lib/CoveyTownController.ts(150,55): error TS2345: Argument of type 'ServerConversationArea | undefined' is not assignable to parameter of type 'ServerConversationArea'.\n  Type 'undefined' is not assignable to type 'ServerConversationArea'.\n","status":"CompileError","estimatedNetTime":52,"hitCount":40,"static":false,"coveredBy":["21","22","24","25","26","27","28","29","30","31","33","34","35","36","37","38"],"location":{"end":{"column":27,"line":149},"start":{"column":11,"line":149}}},{"id":"14","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"src/lib/CoveyTownController.ts(153,9): error TS2532: Object is possibly 'undefined'.\nsrc/lib/CoveyTownController.ts(154,80): error TS2345: Argument of type 'ServerConversationArea | undefined' is not assignable to parameter of type 'ServerConversationArea'.\n  Type 'undefined' is not assignable to type 'ServerConversationArea'.\n","status":"CompileError","estimatedNetTime":52,"hitCount":40,"static":false,"coveredBy":["21","22","24","25","26","27","28","29","30","31","33","34","35","36","37","38"],"location":{"end":{"column":23,"line":152},"start":{"column":11,"line":152}}},{"id":"15","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"src/lib/CoveyTownController.ts(153,9): error TS2532: Object is possibly 'undefined'.\nsrc/lib/CoveyTownController.ts(154,80): error TS2345: Argument of type 'ServerConversationArea | undefined' is not assignable to parameter of type 'ServerConversationArea'.\n  Type 'undefined' is not assignable to type 'ServerConversationArea'.\n","status":"CompileError","estimatedNetTime":52,"hitCount":40,"static":false,"coveredBy":["21","22","24","25","26","27","28","29","30","31","33","34","35","36","37","38"],"location":{"end":{"column":23,"line":152},"start":{"column":11,"line":152}}},{"id":"6","mutatorName":"EqualityOperator","replacement":"conv.label !== location.conversationLabel","statusReason":"Error: expect(received).toEqual(expected) // deep equality\n\nExpected: \"newConversationArea1 Label\"\nReceived: \"label of the conversation area\"\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:381:52\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":55,"hitCount":74,"static":false,"testsCompleted":18,"killedBy":["21"],"coveredBy":["21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38"],"location":{"end":{"column":56,"line":141},"start":{"column":15,"line":141}}},{"id":"3","mutatorName":"ArrowFunction","replacement":"() => undefined","statusReason":"Error: expect(received).toEqual(expected) // deep equality\n\nExpected: \"newConversationArea1 Label\"\nReceived: undefined\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:381:52\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":61,"hitCount":55,"static":false,"testsCompleted":23,"killedBy":["21"],"coveredBy":["2","6","13","18","20","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38"],"location":{"end":{"column":56,"line":141},"start":{"column":7,"line":141}}},{"id":"9","mutatorName":"EqualityOperator","replacement":"conversation === prevConversation","statusReason":"Error: expect(received).toEqual(expected) // deep equality\n\nExpected: \"Hog1fFnEqc452iTdcCw_f\"\nReceived: undefined\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:384:54\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":61,"hitCount":55,"static":false,"testsCompleted":23,"killedBy":["21"],"coveredBy":["2","6","13","18","20","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38"],"location":{"end":{"column":42,"line":148},"start":{"column":9,"line":148}}},{"id":"10","mutatorName":"BlockStatement","replacement":"{}","statusReason":"Error: expect(received).toEqual(expected) // deep equality\n\nExpected: \"Jt--mVKshgQbVAxMexhPQ\"\nReceived: undefined\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:384:54\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":52,"hitCount":40,"static":false,"testsCompleted":16,"killedBy":["21"],"coveredBy":["21","22","24","25","26","27","28","29","30","31","33","34","35","36","37","38"],"location":{"end":{"column":6,"line":156},"start":{"column":44,"line":148}}},{"id":"13","mutatorName":"BlockStatement","replacement":"{}","statusReason":"Error: expect(jest.fn()).toBeCalledTimes(expected)\n\nExpected number of calls: 3\nReceived number of calls: 2\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:716:54\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:27:71\n    at new Promise (<anonymous>)\n    at Object.<anonymous>.__awaiter (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:23:12)\n    at Object.<anonymous> (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:630:85)\n    at Object.asyncJestTest (/Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37)\n    at /Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/queueRunner.js:45:12\n    at new Promise (<anonymous>)","status":"Killed","estimatedNetTime":24,"hitCount":8,"static":false,"testsCompleted":7,"killedBy":["24"],"coveredBy":["21","24","26","34","35","36","37"],"location":{"end":{"column":8,"line":151},"start":{"column":29,"line":149}}},{"id":"16","mutatorName":"BlockStatement","replacement":"{}","statusReason":"Error: expect(received).toEqual(expected) // deep equality\n\nExpected: \"XDlKfZ5DaoZjPjXT2wq8n\"\nReceived: undefined\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:384:54\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":52,"hitCount":36,"static":false,"testsCompleted":16,"killedBy":["21"],"coveredBy":["21","22","24","25","26","27","28","29","30","31","33","34","35","36","37","38"],"location":{"end":{"column":8,"line":155},"start":{"column":25,"line":152}}},{"id":"18","mutatorName":"ArrowFunction","replacement":"() => undefined","statusReason":"Error: expect(received).toContain(expected) // indexOf\n\nExpected value: \"mZuccngO9INDZsEiZc-qG\"\nReceived array: [\"4rrlbdy7nxeu_3CdmdYKI\", \"OBBPh03Z-2FVACWFAHQEe\"]\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:1058:49\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":41,"hitCount":17,"static":false,"testsCompleted":12,"killedBy":["28"],"coveredBy":["21","22","24","26","28","30","31","34","35","36","37","38"],"location":{"end":{"column":64,"line":172},"start":{"column":44,"line":172}}},{"id":"4","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"Error: expect(received).toEqual(expected) // deep equality\n\n- Expected  - 5\n+ Received  + 7\n\n  Object {\n    \"boundingBox\": Object {\n      \"height\": 5,\n      \"width\": 5,\n-     \"x\": 20,\n-     \"y\": 20,\n+     \"x\": 10,\n+     \"y\": 10,\n    },\n-   \"label\": \"invalidConversation\",\n-   \"occupantsByID\": Array [],\n-   \"topic\": \"invalid\",\n+   \"label\": \"newConversationArea1 Label\",\n+   \"occupantsByID\": Array [\n+     \"OYI67WZZF1Iqh4GKnGZq_\",\n+   ],\n+   \"topic\": \"newConversationArea1 Topic\",\n  }\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:523:45\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":55,"hitCount":74,"static":false,"testsCompleted":18,"killedBy":["22"],"coveredBy":["21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38"],"location":{"end":{"column":56,"line":141},"start":{"column":15,"line":141}}},{"id":"17","mutatorName":"ArrowFunction","replacement":"() => undefined","statusReason":"Error: expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n- Expected\n+ Received\n\n  Object {\n    \"boundingBox\": Object {\n-     \"height\": 50,\n-     \"width\": 50,\n-     \"x\": 5,\n-     \"y\": 5,\n+     \"height\": 5,\n+     \"width\": 5,\n+     \"x\": 40,\n+     \"y\": 40,\n    },\n-   \"label\": \"newConversationArea1 Label\",\n-   \"occupantsByID\": Array [\n-     \"VvqTG2iRSqBUl_r3xM01s\",\n-   ],\n-   \"topic\": \"newConversationArea1 Topic\",\n+   \"label\": \"label of the conversation area\",\n+   \"occupantsByID\": Array [],\n+   \"topic\": \"newConversationArea1 Topic 2\",\n  },\n\nNumber of calls: 1\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:386:56\n    at Array.forEach (<anonymous>)\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:385:21\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":52,"hitCount":36,"static":false,"testsCompleted":16,"killedBy":["21"],"coveredBy":["21","22","24","25","26","27","28","29","30","31","33","34","35","36","37","38"],"location":{"end":{"column":93,"line":154},"start":{"column":33,"line":154}}},{"id":"19","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"Error: expect(received).toContain(expected) // indexOf\n\nExpected value: \"1Da5h5EqmNCa8O3e0u7TO\"\nReceived array: [\"Ajp6_nB3VcYh8zkV2w4do\", \"0ma4RgQWC9zylY_4JicSe\"]\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:1057:49\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":41,"hitCount":18,"static":false,"testsCompleted":12,"killedBy":["28"],"coveredBy":["21","22","24","26","28","30","31","34","35","36","37","38"],"location":{"end":{"column":64,"line":172},"start":{"column":49,"line":172}}},{"id":"20","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"Error: expect(received).toContain(expected) // indexOf\n\nExpected value: \"ivPMIEobwfZ4q0t879mi8\"\nReceived array: [\"iioM1tBSI8-ENMDsXHe6W\", \"0nuhzH49ySa0HJeqbGNpO\"]\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:1058:49\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":41,"hitCount":18,"static":false,"testsCompleted":12,"killedBy":["28"],"coveredBy":["21","22","24","26","28","30","31","34","35","36","37","38"],"location":{"end":{"column":64,"line":172},"start":{"column":49,"line":172}}},{"id":"21","mutatorName":"EqualityOperator","replacement":"p !== player.id","statusReason":"Error: expect(received).toContain(expected) // indexOf\n\nExpected value: \"b4a_R6EsjdD_W9w6nx0XT\"\nReceived array: [\"2tdvNYHveRHd5vMMngcWR\", \"dRQhoBJHhtCWloSTgEze3\"]\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:1057:49\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":41,"hitCount":18,"static":false,"testsCompleted":12,"killedBy":["28"],"coveredBy":["21","22","24","26","28","30","31","34","35","36","37","38"],"location":{"end":{"column":64,"line":172},"start":{"column":49,"line":172}}},{"id":"22","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"Error: expect(jest.fn()).toBeCalledTimes(expected)\n\nExpected number of calls: 3\nReceived number of calls: 2\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:716:54\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:27:71\n    at new Promise (<anonymous>)\n    at Object.<anonymous>.__awaiter (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:23:12)\n    at Object.<anonymous> (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:630:85)\n    at Object.asyncJestTest (/Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37)\n    at /Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/queueRunner.js:45:12\n    at new Promise (<anonymous>)","status":"Killed","estimatedNetTime":41,"hitCount":17,"static":false,"testsCompleted":12,"killedBy":["24"],"coveredBy":["21","22","24","26","28","30","31","34","35","36","37","38"],"location":{"end":{"column":48,"line":175},"start":{"column":9,"line":175}}},{"id":"23","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"Error: expect(jest.fn()).toHaveBeenCalledTimes(expected)\n\nExpected number of calls: 3\nReceived number of calls: 4\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:970:54\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":41,"hitCount":17,"static":false,"testsCompleted":12,"killedBy":["26"],"coveredBy":["21","22","24","26","28","30","31","34","35","36","37","38"],"location":{"end":{"column":48,"line":175},"start":{"column":9,"line":175}}},{"id":"24","mutatorName":"EqualityOperator","replacement":"conversation.occupantsByID.length !== 0","statusReason":"Error: expect(jest.fn()).toBeCalledTimes(expected)\n\nExpected number of calls: 3\nReceived number of calls: 2\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:716:54\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:27:71\n    at new Promise (<anonymous>)\n    at Object.<anonymous>.__awaiter (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:23:12)\n    at Object.<anonymous> (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:630:85)\n    at Object.asyncJestTest (/Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37)\n    at /Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/queueRunner.js:45:12\n    at new Promise (<anonymous>)","status":"Killed","estimatedNetTime":41,"hitCount":17,"static":false,"testsCompleted":12,"killedBy":["24"],"coveredBy":["21","22","24","26","28","30","31","34","35","36","37","38"],"location":{"end":{"column":48,"line":175},"start":{"column":9,"line":175}}},{"id":"25","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: true\nReceived: false\n    at Object.<anonymous> (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:286:22)\n    at Object.asyncJestTest (/Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37)\n    at /Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/queueRunner.js:45:12\n    at new Promise (<anonymous>)\n    at mapper (/Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/queueRunner.js:28:19)\n    at /Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/queueRunner.js:75:41","status":"Killed","estimatedNetTime":1071,"hitCount":59,"static":false,"testsCompleted":22,"killedBy":["19"],"coveredBy":["19","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38","39","40","42"],"location":{"end":{"column":8,"line":203},"start":{"column":7,"line":201}}},{"id":"26","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: false\nReceived: true\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:500:24\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:27:71\n    at new Promise (<anonymous>)\n    at Object.<anonymous>.__awaiter (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:23:12)\n    at Object.<anonymous> (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:460:59)\n    at Object.asyncJestTest (/Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37)\n    at /Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/queueRunner.js:45:12\n    at new Promise (<anonymous>)","status":"Killed","estimatedNetTime":1071,"hitCount":59,"static":false,"testsCompleted":22,"killedBy":["22"],"coveredBy":["19","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38","39","40","42"],"location":{"end":{"column":8,"line":203},"start":{"column":7,"line":201}}},{"id":"27","mutatorName":"ArrowFunction","replacement":"() => undefined","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: false\nReceived: true\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:500:24\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:27:71\n    at new Promise (<anonymous>)\n    at Object.<anonymous>.__awaiter (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:23:12)\n    at Object.<anonymous> (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:460:59)\n    at Object.asyncJestTest (/Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37)\n    at /Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/queueRunner.js:45:12\n    at new Promise (<anonymous>)","status":"Killed","estimatedNetTime":1071,"hitCount":59,"static":false,"testsCompleted":22,"killedBy":["22"],"coveredBy":["19","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38","39","40","42"],"location":{"end":{"column":95,"line":202},"start":{"column":9,"line":202}}},{"id":"28","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: true\nReceived: false\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:372:25\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:27:71\n    at new Promise (<anonymous>)\n    at Object.<anonymous>.__awaiter (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:23:12)\n    at Object.<anonymous> (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:327:57)\n    at Object.asyncJestTest (/Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37)\n    at /Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/queueRunner.js:45:12\n    at new Promise (<anonymous>)","status":"Killed","estimatedNetTime":50,"hitCount":54,"static":false,"testsCompleted":14,"killedBy":["21"],"coveredBy":["21","22","23","24","25","26","30","31","32","33","34","35","36","37"],"location":{"end":{"column":95,"line":202},"start":{"column":37,"line":202}}},{"id":"29","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: false\nReceived: true\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:500:24\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:27:71\n    at new Promise (<anonymous>)\n    at Object.<anonymous>.__awaiter (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:23:12)\n    at Object.<anonymous> (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:460:59)\n    at Object.asyncJestTest (/Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37)\n    at /Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/queueRunner.js:45:12\n    at new Promise (<anonymous>)","status":"Killed","estimatedNetTime":50,"hitCount":54,"static":false,"testsCompleted":14,"killedBy":["22"],"coveredBy":["21","22","23","24","25","26","30","31","32","33","34","35","36","37"],"location":{"end":{"column":95,"line":202},"start":{"column":37,"line":202}}},{"id":"30","mutatorName":"EqualityOperator","replacement":"eachExistingConversation.label !== _conversationArea.label","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: true\nReceived: false\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:372:25\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:27:71\n    at new Promise (<anonymous>)\n    at Object.<anonymous>.__awaiter (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:23:12)\n    at Object.<anonymous> (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:327:57)\n    at Object.asyncJestTest (/Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37)\n    at /Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/queueRunner.js:45:12\n    at new Promise (<anonymous>)","status":"Killed","estimatedNetTime":50,"hitCount":54,"static":false,"testsCompleted":14,"killedBy":["21"],"coveredBy":["21","22","23","24","25","26","30","31","32","33","34","35","36","37"],"location":{"end":{"column":95,"line":202},"start":{"column":37,"line":202}}},{"id":"31","mutatorName":"BooleanLiteral","replacement":"true","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: false\nReceived: true\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:500:24\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:27:71\n    at new Promise (<anonymous>)\n    at Object.<anonymous>.__awaiter (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:23:12)\n    at Object.<anonymous> (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:460:59)\n    at Object.asyncJestTest (/Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37)\n    at /Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/queueRunner.js:45:12\n    at new Promise (<anonymous>)","status":"Killed","estimatedNetTime":18,"hitCount":6,"static":false,"testsCompleted":4,"killedBy":["22"],"coveredBy":["22","23","24","25"],"location":{"end":{"column":19,"line":205},"start":{"column":14,"line":205}}},{"id":"32","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: true\nReceived: false\n    at Object.<anonymous> (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:286:22)\n    at Object.asyncJestTest (/Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37)\n    at /Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/queueRunner.js:45:12\n    at new Promise (<anonymous>)\n    at mapper (/Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/queueRunner.js:28:19)\n    at /Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/queueRunner.js:75:41","status":"Killed","estimatedNetTime":1071,"hitCount":53,"static":false,"testsCompleted":22,"killedBy":["19"],"coveredBy":["19","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38","39","40","42"],"location":{"end":{"column":39,"line":206},"start":{"column":9,"line":206}}},{"id":"33","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: false\nReceived: true\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:801:23\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:27:71\n    at new Promise (<anonymous>)\n    at Object.<anonymous>.__awaiter (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:23:12)\n    at Object.<anonymous> (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:746:123)\n    at Object.asyncJestTest (/Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37)\n    at /Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/queueRunner.js:45:12\n    at new Promise (<anonymous>)","status":"Killed","estimatedNetTime":1071,"hitCount":53,"static":false,"testsCompleted":22,"killedBy":["25"],"coveredBy":["19","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38","39","40","42"],"location":{"end":{"column":39,"line":206},"start":{"column":9,"line":206}}},{"id":"34","mutatorName":"EqualityOperator","replacement":"_conversationArea.topic !== ''","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: true\nReceived: false\n    at Object.<anonymous> (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:286:22)\n    at Object.asyncJestTest (/Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37)\n    at /Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/queueRunner.js:45:12\n    at new Promise (<anonymous>)\n    at mapper (/Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/queueRunner.js:28:19)\n    at /Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/queueRunner.js:75:41","status":"Killed","estimatedNetTime":1071,"hitCount":53,"static":false,"testsCompleted":22,"killedBy":["19"],"coveredBy":["19","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38","39","40","42"],"location":{"end":{"column":39,"line":206},"start":{"column":9,"line":206}}},{"id":"35","mutatorName":"StringLiteral","replacement":"\"Stryker was here!\"","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: false\nReceived: true\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:801:23\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:27:71\n    at new Promise (<anonymous>)\n    at Object.<anonymous>.__awaiter (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:23:12)\n    at Object.<anonymous> (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:746:123)\n    at Object.asyncJestTest (/Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37)\n    at /Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/queueRunner.js:45:12\n    at new Promise (<anonymous>)","status":"Killed","estimatedNetTime":1071,"hitCount":53,"static":false,"testsCompleted":22,"killedBy":["25"],"coveredBy":["19","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38","39","40","42"],"location":{"end":{"column":39,"line":206},"start":{"column":37,"line":206}}},{"id":"36","mutatorName":"BlockStatement","replacement":"{}","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: false\nReceived: true\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:801:23\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:27:71\n    at new Promise (<anonymous>)\n    at Object.<anonymous>.__awaiter (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:23:12)\n    at Object.<anonymous> (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:746:123)\n    at Object.asyncJestTest (/Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37)\n    at /Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/queueRunner.js:45:12\n    at new Promise (<anonymous>)","status":"Killed","estimatedNetTime":14,"hitCount":3,"static":false,"testsCompleted":3,"killedBy":["25"],"coveredBy":["24","25","26"],"location":{"end":{"column":6,"line":208},"start":{"column":41,"line":206}}},{"id":"37","mutatorName":"BooleanLiteral","replacement":"true","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: false\nReceived: true\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:703:26\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:27:71\n    at new Promise (<anonymous>)\n    at Object.<anonymous>.__awaiter (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:23:12)\n    at Object.<anonymous> (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:630:85)\n    at Object.asyncJestTest (/Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37)\n    at /Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/queueRunner.js:45:12\n    at new Promise (<anonymous>)","status":"Killed","estimatedNetTime":14,"hitCount":3,"static":false,"testsCompleted":3,"killedBy":["24"],"coveredBy":["24","25","26"],"location":{"end":{"column":19,"line":207},"start":{"column":14,"line":207}}},{"id":"39","mutatorName":"BlockStatement","replacement":"{}","statusReason":"Error: expect(received).toEqual(expected) // deep equality\n\nExpected: {\"boundingBox\": {\"height\": 10, \"width\": 10, \"x\": 20, \"y\": 20}, \"label\": \"invalidConversation\", \"occupantsByID\": [\"6gf22oK_FlEZ57uBe6SBm\"], \"topic\": \"invalid\"}\nReceived: undefined\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:603:45\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":2,"hitCount":1,"static":false,"testsCompleted":1,"killedBy":["23"],"coveredBy":["23"],"location":{"end":{"column":6,"line":224},"start":{"column":49,"line":222}}},{"id":"38","mutatorName":"ArrowFunction","replacement":"() => undefined","statusReason":"Error: expect(received).toEqual(expected) // deep equality\n\nExpected: {\"boundingBox\": {\"height\": 10, \"width\": 10, \"x\": 20, \"y\": 20}, \"label\": \"invalidConversation\", \"occupantsByID\": [], \"topic\": \"invalid\"}\nReceived: undefined\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:603:45\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":1071,"hitCount":41,"static":false,"testsCompleted":22,"killedBy":["23"],"coveredBy":["19","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38","39","40","42"],"location":{"end":{"column":93,"line":221},"start":{"column":59,"line":221}}},{"id":"40","mutatorName":"ArrowFunction","replacement":"() => undefined","statusReason":"src/lib/CoveyTownController.ts(225,5): error TS2322: Type 'undefined[]' is not assignable to type 'string[]'.\n  Type 'undefined' is not assignable to type 'string'.\n","status":"CompileError","estimatedNetTime":1071,"hitCount":41,"static":false,"coveredBy":["19","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38","39","40","42"],"location":{"end":{"column":78,"line":225},"start":{"column":59,"line":225}}}],"source":"import { customAlphabet, nanoid } from 'nanoid';\nimport { BoundingBox, ServerConversationArea } from '../client/TownsServiceClient';\nimport { UserLocation } from '../CoveyTypes';\nimport CoveyTownListener from '../types/CoveyTownListener';\nimport Player from '../types/Player';\nimport PlayerSession from '../types/PlayerSession';\nimport IVideoClient from './IVideoClient';\nimport TwilioVideo from './TwilioVideo';\n\nconst friendlyNanoID = customAlphabet('1234567890ABCDEF', 8);\n\n/**\n * The CoveyTownController implements the logic for each town: managing the various events that\n * can occur (e.g. joining a town, moving, leaving a town)\n */\nexport default class CoveyTownController {\n  get capacity(): number {\n    return this._capacity;\n  }\n\n  set isPubliclyListed(value: boolean) {\n    this._isPubliclyListed = value;\n  }\n\n  get isPubliclyListed(): boolean {\n    return this._isPubliclyListed;\n  }\n\n  get townUpdatePassword(): string {\n    return this._townUpdatePassword;\n  }\n\n  get players(): Player[] {\n    return this._players;\n  }\n\n  get occupancy(): number {\n    return this._listeners.length;\n  }\n\n  get friendlyName(): string {\n    return this._friendlyName;\n  }\n\n  set friendlyName(value: string) {\n    this._friendlyName = value;\n  }\n\n  get coveyTownID(): string {\n    return this._coveyTownID;\n  }\n\n  get conversationAreas(): ServerConversationArea[] {\n    return this._conversationAreas;\n  }\n\n  /** The list of players currently in the town * */\n  private _players: Player[] = [];\n\n  /** The list of valid sessions for this town * */\n  private _sessions: PlayerSession[] = [];\n\n  /** The videoClient that this CoveyTown will use to provision video resources * */\n  private _videoClient: IVideoClient = TwilioVideo.getInstance();\n\n  /** The list of CoveyTownListeners that are subscribed to events in this town * */\n  private _listeners: CoveyTownListener[] = [];\n\n  /** The list of currently active ConversationAreas in this town */\n  private _conversationAreas: ServerConversationArea[] = [];\n\n  private readonly _coveyTownID: string;\n\n  private _friendlyName: string;\n\n  private readonly _townUpdatePassword: string;\n\n  private _isPubliclyListed: boolean;\n\n  private _capacity: number;\n\n  constructor(friendlyName: string, isPubliclyListed: boolean) {\n    this._coveyTownID = process.env.DEMO_TOWN_ID === friendlyName ? friendlyName : friendlyNanoID();\n    this._capacity = 50;\n    this._townUpdatePassword = nanoid(24);\n    this._isPubliclyListed = isPubliclyListed;\n    this._friendlyName = friendlyName;\n  }\n\n  /**\n   * Adds a player to this Covey Town, provisioning the necessary credentials for the\n   * player, and returning them\n   *\n   * @param newPlayer The new player to add to the town\n   */\n  async addPlayer(newPlayer: Player): Promise<PlayerSession> {\n    const theSession = new PlayerSession(newPlayer);\n\n    this._sessions.push(theSession);\n    this._players.push(newPlayer);\n\n    // Create a video token for this user to join this town\n    theSession.videoToken = await this._videoClient.getTokenForTown(\n      this._coveyTownID,\n      newPlayer.id,\n    );\n\n    // Notify other players that this player has joined\n    this._listeners.forEach(listener => listener.onPlayerJoined(newPlayer));\n\n    return theSession;\n  }\n\n  /**\n   * Destroys all data related to a player in this town.\n   *\n   * @param session PlayerSession to destroy\n   */\n  destroySession(session: PlayerSession): void {\n    this._players = this._players.filter(p => p.id !== session.player.id);\n    this._sessions = this._sessions.filter(s => s.sessionToken !== session.sessionToken);\n    this._listeners.forEach(listener => listener.onPlayerDisconnected(session.player));\n    const conversation = session.player.activeConversationArea;\n    if (conversation) {\n      this.removePlayerFromConversationArea(session.player, conversation);\n    }\n  }\n\n  /**\n   * Updates the location of a player within the town\n   *\n   * If the player has changed conversation areas, this method also updates the\n   * corresponding ConversationArea objects tracked by the town controller, and dispatches\n   * any onConversationUpdated events as appropriate\n   *\n   * @param player Player to update location for\n   * @param location New location for this player\n   */\n  updatePlayerLocation(player: Player, location: UserLocation): void {\n    const conversation = this.conversationAreas.find(\n      conv => conv.label === location.conversationLabel,\n    );\n    const prevConversation = player.activeConversationArea;\n\n    player.location = location;\n    player.activeConversationArea = conversation;\n\n    if (conversation !== prevConversation) {\n      if (prevConversation) {\n        this.removePlayerFromConversationArea(player, prevConversation);\n      }\n      if (conversation) {\n        conversation.occupantsByID.push(player.id);\n        this._listeners.forEach(listener => listener.onConversationAreaUpdated(conversation));\n      }\n    }\n\n    this._listeners.forEach(listener => listener.onPlayerMoved(player));\n  }\n\n  /**\n   * Removes a player from a conversation area, updating the conversation area's occupants list,\n   * and emitting the appropriate message (area updated or area destroyed)\n   *\n   * Does not update the player's activeConversationArea property.\n   *\n   * @param player Player to remove from conversation area\n   * @param conversation Conversation area to remove player from\n   */\n  removePlayerFromConversationArea(player: Player, conversation: ServerConversationArea): void {\n    conversation.occupantsByID.splice(\n      conversation.occupantsByID.findIndex(p => p === player.id),\n      1,\n    );\n    if (conversation.occupantsByID.length === 0) {\n      this._conversationAreas.splice(\n        this._conversationAreas.findIndex(conv => conv === conversation),\n        1,\n      );\n      this._listeners.forEach(listener => listener.onConversationAreaDestroyed(conversation));\n    } else {\n      this._listeners.forEach(listener => listener.onConversationAreaUpdated(conversation));\n    }\n  }\n\n  /**\n   * Creates a new conversation area in this town if there is not currently an active\n   * conversation with the same label.\n   *\n   * Adds any players who are in the region defined by the conversation area to it.\n   *\n   * Notifies any CoveyTownListeners that the conversation has been updated\n   *\n   * @param _conversationArea Information describing the conversation area to create. Ignores any\n   *  occupantsById that are set on the conversation area that is passed to this method.\n   *\n   * @returns true if the conversation is successfully created, or false if not\n   */\n  addConversationArea(_conversationArea: ServerConversationArea): boolean {\n    if (\n      this._conversationAreas.find(\n        eachExistingConversation => eachExistingConversation.label === _conversationArea.label,\n      )\n    )\n      return false;\n    if (_conversationArea.topic === '') {\n      return false;\n    }\n    if (\n      this._conversationAreas.find(eachExistingConversation =>\n        CoveyTownController.boxesOverlap(\n          eachExistingConversation.boundingBox,\n          _conversationArea.boundingBox,\n        ),\n      ) !== undefined\n    ) {\n      return false;\n    }\n    const newArea: ServerConversationArea = Object.assign(_conversationArea);\n    this._conversationAreas.push(newArea);\n    const playersInThisConversation = this.players.filter(player => player.isWithin(newArea));\n    playersInThisConversation.forEach(player => {\n      player.activeConversationArea = newArea;\n    });\n    newArea.occupantsByID = playersInThisConversation.map(player => player.id);\n    this._listeners.forEach(listener => listener.onConversationAreaUpdated(newArea));\n    return true;\n  }\n\n  /**\n   * Detects whether two bounding boxes overlap and share any points\n   *\n   * @param box1\n   * @param box2\n   * @returns true if the boxes overlap, otherwise false\n   */\n  static boxesOverlap(box1: BoundingBox, box2: BoundingBox): boolean {\n    // Helper function to extract the top left (x1,y1) and bottom right corner (x2,y2) of each bounding box\n    const toRectPoints = (box: BoundingBox) => ({\n      x1: box.x - box.width / 2,\n      x2: box.x + box.width / 2,\n      y1: box.y - box.height / 2,\n      y2: box.y + box.height / 2,\n    });\n    const rect1 = toRectPoints(box1);\n    const rect2 = toRectPoints(box2);\n    const noOverlap =\n      rect1.x1 >= rect2.x2 || rect2.x1 >= rect1.x2 || rect1.y1 >= rect2.y2 || rect2.y1 >= rect1.y2;\n    return !noOverlap;\n  }\n\n  /**\n   * Subscribe to events from this town. Callers should make sure to\n   * unsubscribe when they no longer want those events by calling removeTownListener\n   *\n   * @param listener New listener\n   */\n  addTownListener(listener: CoveyTownListener): void {\n    this._listeners.push(listener);\n  }\n\n  /**\n   * Unsubscribe from events in this town.\n   *\n   * @param listener The listener to unsubscribe, must be a listener that was registered\n   * with addTownListener, or otherwise will be a no-op\n   */\n  removeTownListener(listener: CoveyTownListener): void {\n    this._listeners = this._listeners.filter(v => v !== listener);\n  }\n\n  /**\n   * Fetch a player's session based on the provided session token. Returns undefined if the\n   * session token is not valid.\n   *\n   * @param token\n   */\n  getSessionByToken(token: string): PlayerSession | undefined {\n    return this._sessions.find(p => p.sessionToken === token);\n  }\n\n  disconnectAllPlayers(): void {\n    this._listeners.forEach(listener => listener.onTownDestroyed());\n  }\n}\n"},"/Users/madhur/Downloads/hw3-handout final/src/requestHandlers/CoveyTownRequestHandlers.ts":{"language":"typescript","mutants":[{"id":"41","mutatorName":"BlockStatement","replacement":"{}","statusReason":"src/requestHandlers/CoveyTownRequestHandlers.ts(184,94): error TS2355: A function whose declared type is neither 'void' nor 'any' must return a value.\n","status":"CompileError","estimatedNetTime":1017,"hitCount":5,"static":false,"coveredBy":["40","42","43","44","45"],"location":{"end":{"column":2,"line":199},"start":{"column":133,"line":184}}},{"id":"42","mutatorName":"BooleanLiteral","replacement":"townController?.getSessionByToken(_requestData.sessionToken)","statusReason":"src/requestHandlers/CoveyTownRequestHandlers.ts(192,19): error TS2532: Object is possibly 'undefined'.\n","status":"CompileError","estimatedNetTime":1017,"hitCount":5,"static":false,"coveredBy":["40","42","43","44","45"],"location":{"end":{"column":68,"line":187},"start":{"column":7,"line":187}}},{"id":"43","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"src/requestHandlers/CoveyTownRequestHandlers.ts(192,19): error TS2532: Object is possibly 'undefined'.\n","status":"CompileError","estimatedNetTime":1017,"hitCount":5,"static":false,"coveredBy":["40","42","43","44","45"],"location":{"end":{"column":68,"line":187},"start":{"column":7,"line":187}}},{"id":"44","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"src/requestHandlers/CoveyTownRequestHandlers.ts(192,19): error TS2532: Object is possibly 'undefined'.\n","status":"CompileError","estimatedNetTime":1017,"hitCount":5,"static":false,"coveredBy":["40","42","43","44","45"],"location":{"end":{"column":68,"line":187},"start":{"column":7,"line":187}}},{"id":"45","mutatorName":"OptionalChaining","replacement":"townController.getSessionByToken","statusReason":"src/requestHandlers/CoveyTownRequestHandlers.ts(187,8): error TS2532: Object is possibly 'undefined'.\nsrc/requestHandlers/CoveyTownRequestHandlers.ts(192,19): error TS2532: Object is possibly 'undefined'.\n","status":"CompileError","estimatedNetTime":1017,"hitCount":5,"static":false,"coveredBy":["40","42","43","44","45"],"location":{"end":{"column":41,"line":187},"start":{"column":8,"line":187}}},{"id":"46","mutatorName":"BlockStatement","replacement":"{}","statusReason":"src/requestHandlers/CoveyTownRequestHandlers.ts(188,19): error TS2532: Object is possibly 'undefined'.\n","status":"CompileError","estimatedNetTime":2,"hitCount":2,"static":false,"coveredBy":["43","45"],"location":{"end":{"column":4,"line":191},"start":{"column":69,"line":187}}},{"id":"47","mutatorName":"ObjectLiteral","replacement":"{}","statusReason":"src/requestHandlers/CoveyTownRequestHandlers.ts(188,5): error TS2741: Property 'isOK' is missing in type '{}' but required in type 'ResponseEnvelope<Record<string, null>>'.\n","status":"CompileError","estimatedNetTime":2,"hitCount":2,"static":false,"coveredBy":["43","45"],"location":{"end":{"column":6,"line":190},"start":{"column":12,"line":188}}},{"id":"50","mutatorName":"ObjectLiteral","replacement":"{}","statusReason":"src/requestHandlers/CoveyTownRequestHandlers.ts(194,3): error TS2741: Property 'isOK' is missing in type '{}' but required in type 'ResponseEnvelope<Record<string, null>>'.\n","status":"CompileError","estimatedNetTime":1015,"hitCount":3,"static":false,"coveredBy":["40","42","44"],"location":{"end":{"column":4,"line":198},"start":{"column":10,"line":194}}},{"id":"48","mutatorName":"BooleanLiteral","replacement":"true","statusReason":"Error: expect(received).toEqual(expected) // deep equality\n\n- Expected  - 1\n+ Received  + 1\n\n  Object {\n-   \"isOK\": false,\n+   \"isOK\": true,\n    \"message\": \"Unable to create conversation area TKcDYzimYUYc4KLydfKtd with topic qZGG73BWwA1cyGYBwYg95\",\n    \"response\": Object {},\n  }\n    at Object.<anonymous> (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/client/CoveyTownConversationAPI.test.ts:223:20)\n    at Object.asyncJestTest (/Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37)\n    at /Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/queueRunner.js:45:12\n    at new Promise (<anonymous>)\n    at mapper (/Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/queueRunner.js:28:19)\n    at /Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/queueRunner.js:75:41","status":"Killed","estimatedNetTime":2,"hitCount":2,"static":false,"testsCompleted":2,"killedBy":["43"],"coveredBy":["43","45"],"location":{"end":{"column":18,"line":189},"start":{"column":13,"line":189}}},{"id":"49","mutatorName":"StringLiteral","replacement":"``","statusReason":"Error: expect(received).toEqual(expected) // deep equality\n\n- Expected  - 1\n+ Received  + 1\n\n  Object {\n    \"isOK\": false,\n-   \"message\": \"Unable to create conversation area cXisRot_SoAzqfIYCkRvv with topic ijHGjxluvFQ6zgSm2uLP6\",\n+   \"message\": \"\",\n    \"response\": Object {},\n  }\n    at Object.<anonymous> (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/client/CoveyTownConversationAPI.test.ts:223:20)\n    at Object.asyncJestTest (/Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37)\n    at /Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/queueRunner.js:45:12\n    at new Promise (<anonymous>)\n    at mapper (/Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/queueRunner.js:28:19)\n    at /Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/queueRunner.js:75:41","status":"Killed","estimatedNetTime":2,"hitCount":2,"static":false,"testsCompleted":2,"killedBy":["43"],"coveredBy":["43","45"],"location":{"end":{"column":168,"line":189},"start":{"column":43,"line":189}}},{"id":"51","mutatorName":"BooleanLiteral","replacement":"success","statusReason":"Error: expect(received).toEqual(expected) // deep equality\n\n- Expected  - 1\n+ Received  + 1\n\n  Object {\n    \"isOK\": undefined,\n-   \"message\": \"Unable to create conversation area newConversationArea1 Label with topic newConversationArea1 Topic\",\n+   \"message\": undefined,\n    \"response\": Object {},\n  }\n    at Object.<anonymous> (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/client/CoveyTownConversationAPI.test.ts:278:20)\n    at Object.asyncJestTest (/Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37)\n    at /Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/queueRunner.js:45:12\n    at new Promise (<anonymous>)\n    at mapper (/Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/queueRunner.js:28:19)\n    at /Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/queueRunner.js:75:41\n    at processTicksAndRejections (internal/process/task_queues.js:95:5)","status":"Killed","estimatedNetTime":1015,"hitCount":3,"static":false,"testsCompleted":3,"killedBy":["44"],"coveredBy":["40","42","44"],"location":{"end":{"column":22,"line":197},"start":{"column":14,"line":197}}},{"id":"52","mutatorName":"StringLiteral","replacement":"``","statusReason":"Error: expect(received).toEqual(expected) // deep equality\n\n- Expected  - 1\n+ Received  + 1\n\n  Object {\n    \"isOK\": undefined,\n-   \"message\": \"Unable to create conversation area newConversationArea1 Label with topic newConversationArea1 Topic\",\n+   \"message\": \"\",\n    \"response\": Object {},\n  }\n    at Object.<anonymous> (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/client/CoveyTownConversationAPI.test.ts:278:20)\n    at Object.asyncJestTest (/Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37)\n    at /Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/queueRunner.js:45:12\n    at new Promise (<anonymous>)\n    at mapper (/Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/queueRunner.js:28:19)\n    at /Users/madhur/Downloads/hw3-handout final/node_modules/jest-jasmine2/build/queueRunner.js:75:41","status":"Killed","estimatedNetTime":1,"hitCount":1,"static":false,"testsCompleted":1,"killedBy":["44"],"coveredBy":["44"],"location":{"end":{"column":150,"line":197},"start":{"column":25,"line":197}}}],"source":"import assert from 'assert';\nimport { Socket } from 'socket.io';\nimport Player from '../types/Player';\nimport { CoveyTownList, UserLocation } from '../CoveyTypes';\nimport CoveyTownListener from '../types/CoveyTownListener';\nimport CoveyTownsStore from '../lib/CoveyTownsStore';\nimport { ConversationAreaCreateRequest, ServerConversationArea } from '../client/TownsServiceClient';\n\n/**\n * The format of a request to join a Town in Covey.Town, as dispatched by the server middleware\n */\nexport interface TownJoinRequest {\n  /** userName of the player that would like to join * */\n  userName: string;\n  /** ID of the town that the player would like to join * */\n  coveyTownID: string;\n}\n\n/**\n * The format of a response to join a Town in Covey.Town, as returned by the handler to the server\n * middleware\n */\nexport interface TownJoinResponse {\n  /** Unique ID that represents this player * */\n  coveyUserID: string;\n  /** Secret token that this player should use to authenticate\n   * in future requests to this service * */\n  coveySessionToken: string;\n  /** Secret token that this player should use to authenticate\n   * in future requests to the video service * */\n  providerVideoToken: string;\n  /** List of players currently in this town * */\n  currentPlayers: Player[];\n  /** Friendly name of this town * */\n  friendlyName: string;\n  /** Is this a private town? * */\n  isPubliclyListed: boolean;\n  /** Conversation areas currently active in this town */\n  conversationAreas: ServerConversationArea[];\n}\n\n/**\n * Payload sent by client to create a Town in Covey.Town\n */\nexport interface TownCreateRequest {\n  friendlyName: string;\n  isPubliclyListed: boolean;\n}\n\n/**\n * Response from the server for a Town create request\n */\nexport interface TownCreateResponse {\n  coveyTownID: string;\n  coveyTownPassword: string;\n}\n\n/**\n * Response from the server for a Town list request\n */\nexport interface TownListResponse {\n  towns: CoveyTownList;\n}\n\n/**\n * Payload sent by the client to delete a Town\n */\nexport interface TownDeleteRequest {\n  coveyTownID: string;\n  coveyTownPassword: string;\n}\n\n/**\n * Payload sent by the client to update a Town.\n * N.B., JavaScript is terrible, so:\n * if(!isPubliclyListed) -> evaluates to true if the value is false OR undefined, use ===\n */\nexport interface TownUpdateRequest {\n  coveyTownID: string;\n  coveyTownPassword: string;\n  friendlyName?: string;\n  isPubliclyListed?: boolean;\n}\n\n/**\n * Envelope that wraps any response from the server\n */\nexport interface ResponseEnvelope<T> {\n  isOK: boolean;\n  message?: string;\n  response?: T;\n}\n\n/**\n * A handler to process a player's request to join a town. The flow is:\n *  1. Client makes a TownJoinRequest, this handler is executed\n *  2. Client uses the sessionToken returned by this handler to make a subscription to the town,\n *  @see townSubscriptionHandler for the code that handles that request.\n *\n * @param requestData an object representing the player's request\n */\nexport async function townJoinHandler(requestData: TownJoinRequest): Promise<ResponseEnvelope<TownJoinResponse>> {\n  const townsStore = CoveyTownsStore.getInstance();\n\n  const coveyTownController = townsStore.getControllerForTown(requestData.coveyTownID);\n  if (!coveyTownController) {\n    return {\n      isOK: false,\n      message: 'Error: No such town',\n    };\n  }\n  const newPlayer = new Player(requestData.userName);\n  const newSession = await coveyTownController.addPlayer(newPlayer);\n  assert(newSession.videoToken);\n  return {\n    isOK: true,\n    response: {\n      coveyUserID: newPlayer.id,\n      coveySessionToken: newSession.sessionToken,\n      providerVideoToken: newSession.videoToken,\n      currentPlayers: coveyTownController.players,\n      friendlyName: coveyTownController.friendlyName,\n      isPubliclyListed: coveyTownController.isPubliclyListed,\n      conversationAreas: coveyTownController.conversationAreas,\n    },\n  };\n}\n\nexport function townListHandler(): ResponseEnvelope<TownListResponse> {\n  const townsStore = CoveyTownsStore.getInstance();\n  return {\n    isOK: true,\n    response: { towns: townsStore.getTowns() },\n  };\n}\n\nexport function townCreateHandler(requestData: TownCreateRequest): ResponseEnvelope<TownCreateResponse> {\n  const townsStore = CoveyTownsStore.getInstance();\n  if (requestData.friendlyName.length === 0) {\n    return {\n      isOK: false,\n      message: 'FriendlyName must be specified',\n    };\n  }\n  const newTown = townsStore.createTown(requestData.friendlyName, requestData.isPubliclyListed);\n  return {\n    isOK: true,\n    response: {\n      coveyTownID: newTown.coveyTownID,\n      coveyTownPassword: newTown.townUpdatePassword,\n    },\n  };\n}\n\nexport function townDeleteHandler(requestData: TownDeleteRequest): ResponseEnvelope<Record<string, null>> {\n  const townsStore = CoveyTownsStore.getInstance();\n  const success = townsStore.deleteTown(requestData.coveyTownID, requestData.coveyTownPassword);\n  return {\n    isOK: success,\n    response: {},\n    message: !success ? 'Invalid password. Please double check your town update password.' : undefined,\n  };\n}\n\nexport function townUpdateHandler(requestData: TownUpdateRequest): ResponseEnvelope<Record<string, null>> {\n  const townsStore = CoveyTownsStore.getInstance();\n  const success = townsStore.updateTown(requestData.coveyTownID, requestData.coveyTownPassword, requestData.friendlyName, requestData.isPubliclyListed);\n  return {\n    isOK: success,\n    response: {},\n    message: !success ? 'Invalid password or update values specified. Please double check your town update password.' : undefined,\n  };\n\n}\n\n/**\n * A handler to process the \"Create Conversation Area\" request\n * The intended flow of this handler is:\n * * Fetch the town controller for the specified town ID\n * * Validate that the sessionToken is valid for that town\n * * Ask the TownController to create the conversation area\n * @param _requestData Conversation area create request\n */\nexport function conversationAreaCreateHandler(_requestData: ConversationAreaCreateRequest) : ResponseEnvelope<Record<string, null>> {\n  const townsStore = CoveyTownsStore.getInstance();\n  const townController = townsStore.getControllerForTown(_requestData.coveyTownID);\n  if (!townController?.getSessionByToken(_requestData.sessionToken)){\n    return {\n      isOK: false, response: {}, message: `Unable to create conversation area ${_requestData.conversationArea.label} with topic ${_requestData.conversationArea.topic}`,\n    };\n  }\n  const success = townController.addConversationArea(_requestData.conversationArea);\n\n  return {\n    isOK: success,\n    response: {},\n    message: !success ? `Unable to create conversation area ${_requestData.conversationArea.label} with topic ${_requestData.conversationArea.topic}` : undefined,\n  };\n}\n\n/**\n * An adapter between CoveyTownController's event interface (CoveyTownListener)\n * and the low-level network communication protocol\n *\n * @param socket the Socket object that we will use to communicate with the player\n */\nfunction townSocketAdapter(socket: Socket): CoveyTownListener {\n  return {\n    onPlayerMoved(movedPlayer: Player) {\n      socket.emit('playerMoved', movedPlayer);\n    },\n    onPlayerDisconnected(removedPlayer: Player) {\n      socket.emit('playerDisconnect', removedPlayer);\n    },\n    onPlayerJoined(newPlayer: Player) {\n      socket.emit('newPlayer', newPlayer);\n    },\n    onTownDestroyed() {\n      socket.emit('townClosing');\n      socket.disconnect(true);\n    },\n    onConversationAreaDestroyed(conversation: ServerConversationArea){\n      socket.emit('conversationDestroyed', conversation);\n    },\n    onConversationAreaUpdated(conversation: ServerConversationArea){\n      socket.emit('conversationUpdated', conversation);\n    },\n  };\n}\n\n/**\n * A handler to process a remote player's subscription to updates for a town\n *\n * @param socket the Socket object that we will use to communicate with the player\n */\nexport function townSubscriptionHandler(socket: Socket): void {\n  // Parse the client's session token from the connection\n  // For each player, the session token should be the same string returned by joinTownHandler\n  const { token, coveyTownID } = socket.handshake.auth as { token: string; coveyTownID: string };\n\n  const townController = CoveyTownsStore.getInstance()\n    .getControllerForTown(coveyTownID);\n\n  // Retrieve our metadata about this player from the TownController\n  const s = townController?.getSessionByToken(token);\n  if (!s || !townController) {\n    // No valid session exists for this token, hence this client's connection should be terminated\n    socket.disconnect(true);\n    return;\n  }\n\n  // Create an adapter that will translate events from the CoveyTownController into\n  // events that the socket protocol knows about\n  const listener = townSocketAdapter(socket);\n  townController.addTownListener(listener);\n\n  // Register an event listener for the client socket: if the client disconnects,\n  // clean up our listener adapter, and then let the CoveyTownController know that the\n  // player's session is disconnected\n  socket.on('disconnect', () => {\n    townController.removeTownListener(listener);\n    townController.destroySession(s);\n  });\n\n  // Register an event listener for the client socket: if the client updates their\n  // location, inform the CoveyTownController\n  socket.on('playerMovement', (movementData: UserLocation) => {\n    townController.updatePlayerLocation(s.player, movementData);\n  });\n}\n\n\n"},"/Users/madhur/Downloads/hw3-handout final/src/router/towns.ts":{"language":"typescript","mutants":[{"id":"54","mutatorName":"StringLiteral","replacement":"\"\"","status":"Survived","estimatedNetTime":10,"hitCount":1,"static":false,"testsCompleted":2,"coveredBy":["41"],"location":{"end":{"column":84,"line":113},"start":{"column":18,"line":113}}},{"id":"53","mutatorName":"ObjectLiteral","replacement":"{}","status":"Survived","estimatedNetTime":10,"hitCount":1,"static":false,"testsCompleted":2,"coveredBy":["41"],"location":{"end":{"column":8,"line":114},"start":{"column":58,"line":112}}},{"id":"55","mutatorName":"ObjectLiteral","replacement":"{}","status":"Survived","estimatedNetTime":1117,"hitCount":1,"static":true,"testsCompleted":6,"location":{"end":{"column":69,"line":118},"start":{"column":44,"line":118}}},{"id":"56","mutatorName":"ObjectLiteral","replacement":"{}","status":"Survived","estimatedNetTime":1117,"hitCount":1,"static":true,"testsCompleted":6,"location":{"end":{"column":67,"line":118},"start":{"column":52,"line":118}}},{"id":"58","mutatorName":"StringLiteral","replacement":"\"\"","status":"Survived","estimatedNetTime":1117,"hitCount":1,"static":true,"testsCompleted":6,"location":{"end":{"column":31,"line":119},"start":{"column":19,"line":119}}},{"id":"57","mutatorName":"StringLiteral","replacement":"\"\"","status":"Survived","estimatedNetTime":1117,"hitCount":1,"static":true,"testsCompleted":6,"location":{"end":{"column":65,"line":118},"start":{"column":62,"line":118}}}],"source":"import express, { Express } from 'express';\nimport io from 'socket.io';\nimport { Server } from 'http';\nimport { StatusCodes } from 'http-status-codes';\nimport {\n  conversationAreaCreateHandler,\n  townCreateHandler,\n  townDeleteHandler,\n  townJoinHandler,\n  townListHandler,\n  townSubscriptionHandler,\n  townUpdateHandler,\n} from '../requestHandlers/CoveyTownRequestHandlers';\nimport { logError } from '../Utils';\n\nexport default function addTownRoutes(http: Server, app: Express): io.Server {\n  /*\n   * Create a new session (aka join a town)\n   */\n  app.post('/sessions', express.json(), async (req, res) => {\n    try {\n      const result = await townJoinHandler({\n        userName: req.body.userName,\n        coveyTownID: req.body.coveyTownID,\n      });\n      res.status(StatusCodes.OK).json(result);\n    } catch (err) {\n      logError(err);\n      res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({\n        message: 'Internal server error, please see log in server for more details',\n      });\n    }\n  });\n\n  /**\n   * Delete a town\n   */\n  app.delete('/towns/:townID/:townPassword', express.json(), async (req, res) => {\n    try {\n      const result = townDeleteHandler({\n        coveyTownID: req.params.townID,\n        coveyTownPassword: req.params.townPassword,\n      });\n      res.status(200).json(result);\n    } catch (err) {\n      logError(err);\n      res.status(500).json({\n        message: 'Internal server error, please see log in server for details',\n      });\n    }\n  });\n\n  /**\n   * List all towns\n   */\n  app.get('/towns', express.json(), async (_req, res) => {\n    try {\n      const result = townListHandler();\n      res.status(StatusCodes.OK).json(result);\n    } catch (err) {\n      logError(err);\n      res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({\n        message: 'Internal server error, please see log in server for more details',\n      });\n    }\n  });\n\n  /**\n   * Create a town\n   */\n  app.post('/towns', express.json(), async (req, res) => {\n    try {\n      const result = townCreateHandler(req.body);\n      res.status(StatusCodes.OK).json(result);\n    } catch (err) {\n      logError(err);\n      res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({\n        message: 'Internal server error, please see log in server for more details',\n      });\n    }\n  });\n  /**\n   * Update a town\n   */\n  app.patch('/towns/:townID', express.json(), async (req, res) => {\n    try {\n      const result = townUpdateHandler({\n        coveyTownID: req.params.townID,\n        isPubliclyListed: req.body.isPubliclyListed,\n        friendlyName: req.body.friendlyName,\n        coveyTownPassword: req.body.coveyTownPassword,\n      });\n      res.status(StatusCodes.OK).json(result);\n    } catch (err) {\n      logError(err);\n      res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({\n        message: 'Internal server error, please see log in server for more details',\n      });\n    }\n  });\n\n  app.post('/towns/:townID/conversationAreas', express.json(), async (req, res) => {\n    try {\n      const result = await conversationAreaCreateHandler({\n        coveyTownID: req.params.townID,\n        sessionToken: req.body.sessionToken,\n        conversationArea: req.body.conversationArea,\n      });\n      res.status(StatusCodes.OK).json(result);\n    } catch (err) {\n      logError(err);\n      res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({\n        message: 'Internal server error, please see log in server for more details',\n      });\n    }\n  });\n\n  const socketServer = new io.Server(http, { cors: { origin: '*' } });\n  socketServer.on('connection', townSubscriptionHandler);\n  return socketServer;\n}\n"},"/Users/madhur/Downloads/hw3-handout final/src/types/Player.ts":{"language":"typescript","mutants":[{"id":"59","mutatorName":"BlockStatement","replacement":"{}","statusReason":"src/types/Player.ts(56,52): error TS2355: A function whose declared type is neither 'void' nor 'any' must return a value.\n","status":"CompileError","estimatedNetTime":1044,"hitCount":24,"static":false,"coveredBy":["21","22","23","24","25","26","34","40","42"],"location":{"end":{"column":4,"line":63},"start":{"column":60,"line":56}}},{"id":"60","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: false\nReceived: true\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:411:54\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":1044,"hitCount":24,"static":false,"testsCompleted":9,"killedBy":["21"],"coveredBy":["21","22","23","24","25","26","34","40","42"],"location":{"end":{"column":89,"line":61},"start":{"column":7,"line":58}}},{"id":"62","mutatorName":"LogicalOperator","replacement":"this.location.x > conversation.boundingBox.x - conversation.boundingBox.width / 2 && this.location.x < conversation.boundingBox.x + conversation.boundingBox.width / 2 && this.location.y > conversation.boundingBox.y - conversation.boundingBox.height / 2 || this.location.y < conversation.boundingBox.y + conversation.boundingBox.height / 2","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: false\nReceived: true\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:411:54\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":1044,"hitCount":24,"static":false,"testsCompleted":9,"killedBy":["21"],"coveredBy":["21","22","23","24","25","26","34","40","42"],"location":{"end":{"column":89,"line":61},"start":{"column":7,"line":58}}},{"id":"61","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: true\nReceived: false\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:400:54\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":1044,"hitCount":24,"static":false,"testsCompleted":9,"killedBy":["21"],"coveredBy":["21","22","23","24","25","26","34","40","42"],"location":{"end":{"column":89,"line":61},"start":{"column":7,"line":58}}},{"id":"63","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: false\nReceived: true\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:411:54\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":1044,"hitCount":24,"static":false,"testsCompleted":9,"killedBy":["21"],"coveredBy":["21","22","23","24","25","26","34","40","42"],"location":{"end":{"column":89,"line":60},"start":{"column":7,"line":58}}},{"id":"64","mutatorName":"LogicalOperator","replacement":"this.location.x > conversation.boundingBox.x - conversation.boundingBox.width / 2 && this.location.x < conversation.boundingBox.x + conversation.boundingBox.width / 2 || this.location.y > conversation.boundingBox.y - conversation.boundingBox.height / 2","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: false\nReceived: true\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:411:54\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":1044,"hitCount":24,"static":false,"testsCompleted":9,"killedBy":["21"],"coveredBy":["21","22","23","24","25","26","34","40","42"],"location":{"end":{"column":89,"line":60},"start":{"column":7,"line":58}}},{"id":"67","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: false\nReceived: true\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:411:54\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":1044,"hitCount":24,"static":false,"testsCompleted":9,"killedBy":["21"],"coveredBy":["21","22","23","24","25","26","34","40","42"],"location":{"end":{"column":88,"line":58},"start":{"column":7,"line":58}}},{"id":"65","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: false\nReceived: true\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:411:54\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":1044,"hitCount":24,"static":false,"testsCompleted":9,"killedBy":["21"],"coveredBy":["21","22","23","24","25","26","34","40","42"],"location":{"end":{"column":88,"line":59},"start":{"column":7,"line":58}}},{"id":"66","mutatorName":"LogicalOperator","replacement":"this.location.x > conversation.boundingBox.x - conversation.boundingBox.width / 2 || this.location.x < conversation.boundingBox.x + conversation.boundingBox.width / 2","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: false\nReceived: true\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:411:54\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":1044,"hitCount":24,"static":false,"testsCompleted":9,"killedBy":["21"],"coveredBy":["21","22","23","24","25","26","34","40","42"],"location":{"end":{"column":88,"line":59},"start":{"column":7,"line":58}}},{"id":"68","mutatorName":"EqualityOperator","replacement":"this.location.x >= conversation.boundingBox.x - conversation.boundingBox.width / 2","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: false\nReceived: true\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:411:54\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":1044,"hitCount":24,"static":false,"testsCompleted":9,"killedBy":["21"],"coveredBy":["21","22","23","24","25","26","34","40","42"],"location":{"end":{"column":88,"line":58},"start":{"column":7,"line":58}}},{"id":"70","mutatorName":"ArithmeticOperator","replacement":"conversation.boundingBox.x + conversation.boundingBox.width / 2","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: true\nReceived: false\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:400:54\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":1044,"hitCount":24,"static":false,"testsCompleted":9,"killedBy":["21"],"coveredBy":["21","22","23","24","25","26","34","40","42"],"location":{"end":{"column":88,"line":58},"start":{"column":25,"line":58}}},{"id":"69","mutatorName":"EqualityOperator","replacement":"this.location.x <= conversation.boundingBox.x - conversation.boundingBox.width / 2","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: true\nReceived: false\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:400:54\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":1044,"hitCount":24,"static":false,"testsCompleted":9,"killedBy":["21"],"coveredBy":["21","22","23","24","25","26","34","40","42"],"location":{"end":{"column":88,"line":58},"start":{"column":7,"line":58}}},{"id":"71","mutatorName":"ArithmeticOperator","replacement":"conversation.boundingBox.width * 2","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: false\nReceived: true\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:411:54\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":1044,"hitCount":24,"static":false,"testsCompleted":9,"killedBy":["21"],"coveredBy":["21","22","23","24","25","26","34","40","42"],"location":{"end":{"column":88,"line":58},"start":{"column":54,"line":58}}},{"id":"73","mutatorName":"EqualityOperator","replacement":"this.location.x <= conversation.boundingBox.x + conversation.boundingBox.width / 2","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: false\nReceived: true\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:422:54\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":28,"hitCount":17,"static":false,"testsCompleted":6,"killedBy":["21"],"coveredBy":["21","22","23","24","25","34"],"location":{"end":{"column":88,"line":59},"start":{"column":7,"line":59}}},{"id":"72","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: false\nReceived: true\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:422:54\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":28,"hitCount":17,"static":false,"testsCompleted":6,"killedBy":["21"],"coveredBy":["21","22","23","24","25","34"],"location":{"end":{"column":88,"line":59},"start":{"column":7,"line":59}}},{"id":"74","mutatorName":"EqualityOperator","replacement":"this.location.x >= conversation.boundingBox.x + conversation.boundingBox.width / 2","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: true\nReceived: false\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:400:54\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":28,"hitCount":17,"static":false,"testsCompleted":6,"killedBy":["21"],"coveredBy":["21","22","23","24","25","34"],"location":{"end":{"column":88,"line":59},"start":{"column":7,"line":59}}},{"id":"75","mutatorName":"ArithmeticOperator","replacement":"conversation.boundingBox.x - conversation.boundingBox.width / 2","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: true\nReceived: false\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:400:54\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":28,"hitCount":17,"static":false,"testsCompleted":6,"killedBy":["21"],"coveredBy":["21","22","23","24","25","34"],"location":{"end":{"column":88,"line":59},"start":{"column":25,"line":59}}},{"id":"76","mutatorName":"ArithmeticOperator","replacement":"conversation.boundingBox.width * 2","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: false\nReceived: true\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:422:54\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":28,"hitCount":17,"static":false,"testsCompleted":6,"killedBy":["21"],"coveredBy":["21","22","23","24","25","34"],"location":{"end":{"column":88,"line":59},"start":{"column":54,"line":59}}},{"id":"77","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: false\nReceived: true\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:444:54\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":24,"hitCount":13,"static":false,"testsCompleted":5,"killedBy":["21"],"coveredBy":["21","22","23","25","34"],"location":{"end":{"column":89,"line":60},"start":{"column":7,"line":60}}},{"id":"79","mutatorName":"EqualityOperator","replacement":"this.location.y <= conversation.boundingBox.y - conversation.boundingBox.height / 2","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: true\nReceived: false\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:400:54\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":24,"hitCount":13,"static":false,"testsCompleted":5,"killedBy":["21"],"coveredBy":["21","22","23","25","34"],"location":{"end":{"column":89,"line":60},"start":{"column":7,"line":60}}},{"id":"78","mutatorName":"EqualityOperator","replacement":"this.location.y >= conversation.boundingBox.y - conversation.boundingBox.height / 2","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: false\nReceived: true\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:444:54\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":24,"hitCount":13,"static":false,"testsCompleted":5,"killedBy":["21"],"coveredBy":["21","22","23","25","34"],"location":{"end":{"column":89,"line":60},"start":{"column":7,"line":60}}},{"id":"81","mutatorName":"ArithmeticOperator","replacement":"conversation.boundingBox.height * 2","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: false\nReceived: true\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:444:54\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":24,"hitCount":13,"static":false,"testsCompleted":5,"killedBy":["21"],"coveredBy":["21","22","23","25","34"],"location":{"end":{"column":89,"line":60},"start":{"column":54,"line":60}}},{"id":"82","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: false\nReceived: true\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:433:54\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":20,"hitCount":11,"static":false,"testsCompleted":4,"killedBy":["21"],"coveredBy":["21","23","25","34"],"location":{"end":{"column":89,"line":61},"start":{"column":7,"line":61}}},{"id":"80","mutatorName":"ArithmeticOperator","replacement":"conversation.boundingBox.y + conversation.boundingBox.height / 2","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: true\nReceived: false\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:400:54\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":24,"hitCount":13,"static":false,"testsCompleted":5,"killedBy":["21"],"coveredBy":["21","22","23","25","34"],"location":{"end":{"column":89,"line":60},"start":{"column":25,"line":60}}},{"id":"83","mutatorName":"EqualityOperator","replacement":"this.location.y <= conversation.boundingBox.y + conversation.boundingBox.height / 2","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: false\nReceived: true\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:433:54\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":20,"hitCount":11,"static":false,"testsCompleted":4,"killedBy":["21"],"coveredBy":["21","23","25","34"],"location":{"end":{"column":89,"line":61},"start":{"column":7,"line":61}}},{"id":"85","mutatorName":"ArithmeticOperator","replacement":"conversation.boundingBox.y - conversation.boundingBox.height / 2","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: true\nReceived: false\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:400:54\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":20,"hitCount":11,"static":false,"testsCompleted":4,"killedBy":["21"],"coveredBy":["21","23","25","34"],"location":{"end":{"column":89,"line":61},"start":{"column":25,"line":61}}},{"id":"84","mutatorName":"EqualityOperator","replacement":"this.location.y >= conversation.boundingBox.y + conversation.boundingBox.height / 2","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: true\nReceived: false\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:400:54\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":20,"hitCount":11,"static":false,"testsCompleted":4,"killedBy":["21"],"coveredBy":["21","23","25","34"],"location":{"end":{"column":89,"line":61},"start":{"column":7,"line":61}}},{"id":"86","mutatorName":"ArithmeticOperator","replacement":"conversation.boundingBox.height * 2","statusReason":"Error: expect(received).toBe(expected) // Object.is equality\n\nExpected: false\nReceived: true\n    at /Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:433:54\n    at step (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:52:23)\n    at Object.next (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:33:53)\n    at fulfilled (/Users/madhur/Downloads/hw3-handout final/.strykerTmp/sandbox3321242/src/lib/CoveyTownController.test.ts:24:58)","status":"Killed","estimatedNetTime":20,"hitCount":11,"static":false,"testsCompleted":4,"killedBy":["21"],"coveredBy":["21","23","25","34"],"location":{"end":{"column":89,"line":61},"start":{"column":54,"line":61}}}],"source":"import { nanoid } from 'nanoid';\nimport { ServerConversationArea } from '../client/TownsServiceClient';\nimport { UserLocation } from '../CoveyTypes';\n\n/**\n * Each user who is connected to a town is represented by a Player object\n */\nexport default class Player {\n  /** The current location of this user in the world map * */\n  public location: UserLocation;\n\n  /** The unique identifier for this player * */\n  private readonly _id: string;\n\n  /** The player's username, which is not guaranteed to be unique within the town * */\n  private readonly _userName: string;\n\n  /** The current ConversationArea that the player is in, or undefined if they are not located within one */\n  private _activeConversationArea?: ServerConversationArea;\n\n  constructor(userName: string) {\n    this.location = {\n      x: 0,\n      y: 0,\n      moving: false,\n      rotation: 'front',\n    };\n    this._userName = userName;\n    this._id = nanoid();\n  }\n\n  get userName(): string {\n    return this._userName;\n  }\n\n  get id(): string {\n    return this._id;\n  }\n\n  get activeConversationArea(): ServerConversationArea | undefined {\n    return this._activeConversationArea;\n  }\n\n  set activeConversationArea(conversationArea: ServerConversationArea | undefined) {\n    this._activeConversationArea = conversationArea;\n  }\n\n  /**\n   * Checks to see if a player's location is within the specified conversation area\n   * \n   * This method is resilient to floating point errors that could arise if any of the coordinates of\n   * `this.location` are dramatically smaller than those of the conversation area's bounding box.\n   * @param conversation \n   * @returns \n   */\n  isWithin(conversation: ServerConversationArea) : boolean {\n    return (\n      this.location.x > conversation.boundingBox.x - conversation.boundingBox.width / 2 &&\n      this.location.x < conversation.boundingBox.x + conversation.boundingBox.width / 2 &&\n      this.location.y > conversation.boundingBox.y - conversation.boundingBox.height / 2 &&\n      this.location.y < conversation.boundingBox.y + conversation.boundingBox.height / 2\n    );\n  }\n\n}\n"}},"schemaVersion":"1.0","thresholds":{"high":80,"low":60,"break":null},"testFiles":{"/Users/madhur/Downloads/hw3-handout final/src/lib/CoveyTownController.test.ts":{"tests":[{"id":"0","name":"CoveyTownController constructor should set the friendlyName property","location":{"start":{"column":3,"line":37}}},{"id":"1","name":"CoveyTownController addPlayer should use the coveyTownID and player ID properties when requesting a video token","location":{"start":{"column":5,"line":43}}},{"id":"2","name":"CoveyTownController town listeners and events should notify added listeners of player movement when updatePlayerLocation is called","location":{"start":{"column":5,"line":66}}},{"id":"3","name":"CoveyTownController town listeners and events should notify added listeners of player disconnections when destroySession is called","location":{"start":{"column":5,"line":74}}},{"id":"4","name":"CoveyTownController town listeners and events should notify added listeners of new players when addPlayer is called","location":{"start":{"column":5,"line":84}}},{"id":"5","name":"CoveyTownController town listeners and events should notify added listeners that the town is destroyed when disconnectAllPlayers is called","location":{"start":{"column":5,"line":91}}},{"id":"6","name":"CoveyTownController town listeners and events should not notify removed listeners of player movement when updatePlayerLocation is called","location":{"start":{"column":5,"line":99}}},{"id":"7","name":"CoveyTownController town listeners and events should not notify removed listeners of player disconnections when destroySession is called","location":{"start":{"column":5,"line":110}}},{"id":"8","name":"CoveyTownController town listeners and events should not notify removed listeners of new players when addPlayer is called","location":{"start":{"column":5,"line":120}}},{"id":"9","name":"CoveyTownController town listeners and events should not notify removed listeners that the town is destroyed when disconnectAllPlayers is called","location":{"start":{"column":5,"line":131}}},{"id":"10","name":"CoveyTownController townSubscriptionHandler should reject connections with invalid town IDs by calling disconnect","location":{"start":{"column":5,"line":154}}},{"id":"11","name":"CoveyTownController townSubscriptionHandler should reject connections with invalid session tokens by calling disconnect","location":{"start":{"column":5,"line":159}}},{"id":"12","name":"CoveyTownController townSubscriptionHandler with a valid session token should add a town listener, which should emit \"newPlayer\" to the socket when a player joins","location":{"start":{"column":7,"line":165}}},{"id":"13","name":"CoveyTownController townSubscriptionHandler with a valid session token should add a town listener, which should emit \"playerMoved\" to the socket when a player moves","location":{"start":{"column":7,"line":175}}},{"id":"14","name":"CoveyTownController townSubscriptionHandler with a valid session token should add a town listener, which should emit \"playerDisconnect\" to the socket when a player disconnects","location":{"start":{"column":7,"line":185}}},{"id":"15","name":"CoveyTownController townSubscriptionHandler with a valid session token should add a town listener, which should emit \"townClosing\" to the socket and disconnect it when disconnectAllPlayers is called","location":{"start":{"column":7,"line":195}}},{"id":"16","name":"CoveyTownController townSubscriptionHandler with a valid session token when a socket disconnect event is fired should remove the town listener for that socket, and stop sending events to it","location":{"start":{"column":9,"line":207}}},{"id":"17","name":"CoveyTownController townSubscriptionHandler with a valid session token when a socket disconnect event is fired should destroy the session corresponding to that socket","location":{"start":{"column":9,"line":226}}},{"id":"18","name":"CoveyTownController townSubscriptionHandler with a valid session token should forward playerMovement events from the socket to subscribed listeners","location":{"start":{"column":7,"line":251}}},{"id":"19","name":"CoveyTownController addConversationArea should add the conversation area to the list of conversation areas","location":{"start":{"column":5,"line":282}}},{"id":"20","name":"CoveyTownController addConversationArea Represents the test case to check for all of the last buggy cases","location":{"start":{"column":5,"line":294}}},{"id":"21","name":"CoveyTownController addConversationArea Represents the checking of the bounding boxes","location":{"start":{"column":5,"line":326}}},{"id":"22","name":"CoveyTownController addConversationArea Represents the checking of the label edge cases","location":{"start":{"column":5,"line":459}}},{"id":"23","name":"CoveyTownController addConversationArea Represents the checking of edge cases for the addConversationArea","location":{"start":{"column":5,"line":544}}},{"id":"24","name":"CoveyTownController addConversationArea Represents the adding of players and conversation areas that are invalid ","location":{"start":{"column":5,"line":629}}},{"id":"25","name":"CoveyTownController addConversationArea Represents the case of checking for the number of conversation areas, whether they are valid and can be added  ","location":{"start":{"column":5,"line":745}}},{"id":"26","name":"CoveyTownController addConversationArea Represents the edge cases to be checked throughout the addConversation area function","location":{"start":{"column":5,"line":881}}},{"id":"27","name":"CoveyTownController updatePlayerLocation should respect the conversation area reported by the player userLocation.conversationLabel, and not override it based on the player's x,y location","location":{"start":{"column":5,"line":991}}},{"id":"28","name":"CoveyTownController updatePlayerLocation should check for the index mutation of the player when the player has been removed from the given index","location":{"start":{"column":5,"line":1016}}},{"id":"29","name":"CoveyTownController updatePlayerLocation should emit an onConversationUpdated event when a conversation area gets a new occupant","location":{"start":{"column":5,"line":1059}}},{"id":"30","name":"CoveyTownController updatePlayerLocation Represents the case of checking the entire remove helper function(additional tests)","location":{"start":{"column":5,"line":1083}}},{"id":"31","name":"CoveyTownController updatePlayerLocation Represents the case of checking the edge case of when a player can be removed","location":{"start":{"column":5,"line":1206}}},{"id":"32","name":"CoveyTownController updatePlayerLocation Represents the case of checking the first part of the code when we are checking for the conversation area validity","location":{"start":{"column":5,"line":1274}}},{"id":"33","name":"CoveyTownController updatePlayerLocation Represents the case of checking conversation area being updated if the player stays in it","location":{"start":{"column":5,"line":1340}}},{"id":"34","name":"CoveyTownController updatePlayerLocation Represents the case of checking the player and the location states and making sure that they are valid","location":{"start":{"column":5,"line":1403}}},{"id":"35","name":"CoveyTownController updatePlayerLocation Represents the case of now checking when the player has been updated by location, if the removal and adding is valid to previous and new conversation areas respectively","location":{"start":{"column":5,"line":1502}}},{"id":"36","name":"CoveyTownController updatePlayerLocation Represents the case of checking whether the town listener is called when it is destroyed or added","location":{"start":{"column":5,"line":1625}}},{"id":"37","name":"CoveyTownController updatePlayerLocation Should remove the player from its existing or active conversation area when the location is updated since the player moves into a new conversation area","location":{"start":{"column":5,"line":1716}}},{"id":"38","name":"CoveyTownController destroySession Tests for when a players session is destroyed, they should be removed from the conversation area","location":{"start":{"column":5,"line":1894}}},{"id":"39","name":"CoveyTownController destroySession should emit an onPlayerDisconnected event when a player is disconnected/destroyed or removed from its given conversation area","location":{"start":{"column":5,"line":1945}}}],"source":"import { nanoid } from 'nanoid';\nimport { mock, mockDeep, mockReset } from 'jest-mock-extended';\nimport { Socket } from 'socket.io';\n// import { platform } from 'os';\n// import { platform } from 'os';\n// import { SecondaryAuthTokenContext } from 'twilio/lib/rest/accounts/v1/secondaryAuthToken';\nimport TwilioVideo from './TwilioVideo';\nimport Player from '../types/Player';\nimport CoveyTownController from './CoveyTownController';\nimport CoveyTownListener from '../types/CoveyTownListener';\nimport { UserLocation } from '../CoveyTypes';\nimport PlayerSession from '../types/PlayerSession';\nimport {\n  townSubscriptionHandler,\n  // townUpdateHandler,\n} from '../requestHandlers/CoveyTownRequestHandlers';\nimport CoveyTownsStore from './CoveyTownsStore';\nimport * as TestUtils from '../client/TestUtils';\n// import { SecondaryAuthTokenContext } from 'twilio/lib/rest/accounts/v1/secondaryAuthToken';\n\nconst mockTwilioVideo = mockDeep<TwilioVideo>();\njest.spyOn(TwilioVideo, 'getInstance').mockReturnValue(mockTwilioVideo);\n\nfunction generateTestLocation(): UserLocation {\n  return {\n    rotation: 'back',\n    moving: Math.random() < 0.5,\n    x: Math.floor(Math.random() * 100),\n    y: Math.floor(Math.random() * 100),\n  };\n}\n\ndescribe('CoveyTownController', () => {\n  beforeEach(() => {\n    mockTwilioVideo.getTokenForTown.mockClear();\n  });\n  it('constructor should set the friendlyName property', () => {\n    const townName = `FriendlyNameTest-${nanoid()}`;\n    const townController = new CoveyTownController(townName, false);\n    expect(townController.friendlyName).toBe(townName);\n  });\n  describe('addPlayer', () => {\n    it('should use the coveyTownID and player ID properties when requesting a video token', async () => {\n      const townName = `FriendlyNameTest-${nanoid()}`;\n      const townController = new CoveyTownController(townName, false);\n      const newPlayerSession = await townController.addPlayer(new Player(nanoid()));\n      expect(mockTwilioVideo.getTokenForTown).toBeCalledTimes(1);\n      expect(mockTwilioVideo.getTokenForTown).toBeCalledWith(\n        townController.coveyTownID,\n        newPlayerSession.player.id,\n      );\n    });\n  });\n  describe('town listeners and events', () => {\n    let testingTown: CoveyTownController;\n    const mockListeners = [\n      mock<CoveyTownListener>(),\n      mock<CoveyTownListener>(),\n      mock<CoveyTownListener>(),\n    ];\n    beforeEach(() => {\n      const townName = `town listeners and events tests ${nanoid()}`;\n      testingTown = new CoveyTownController(townName, false);\n      mockListeners.forEach(mockReset);\n    });\n    it('should notify added listeners of player movement when updatePlayerLocation is called', async () => {\n      const player = new Player('test player');\n      await testingTown.addPlayer(player);\n      const newLocation = generateTestLocation();\n      mockListeners.forEach(listener => testingTown.addTownListener(listener));\n      testingTown.updatePlayerLocation(player, newLocation);\n      mockListeners.forEach(listener => expect(listener.onPlayerMoved).toBeCalledWith(player));\n    });\n    it('should notify added listeners of player disconnections when destroySession is called', async () => {\n      const player = new Player('test player');\n      const session = await testingTown.addPlayer(player);\n\n      mockListeners.forEach(listener => testingTown.addTownListener(listener));\n      testingTown.destroySession(session);\n      mockListeners.forEach(listener =>\n        expect(listener.onPlayerDisconnected).toBeCalledWith(player),\n      );\n    });\n    it('should notify added listeners of new players when addPlayer is called', async () => {\n      mockListeners.forEach(listener => testingTown.addTownListener(listener));\n\n      const player = new Player('test player');\n      await testingTown.addPlayer(player);\n      mockListeners.forEach(listener => expect(listener.onPlayerJoined).toBeCalledWith(player));\n    });\n    it('should notify added listeners that the town is destroyed when disconnectAllPlayers is called', async () => {\n      const player = new Player('test player');\n      await testingTown.addPlayer(player);\n\n      mockListeners.forEach(listener => testingTown.addTownListener(listener));\n      testingTown.disconnectAllPlayers();\n      mockListeners.forEach(listener => expect(listener.onTownDestroyed).toBeCalled());\n    });\n    it('should not notify removed listeners of player movement when updatePlayerLocation is called', async () => {\n      const player = new Player('test player');\n      await testingTown.addPlayer(player);\n\n      mockListeners.forEach(listener => testingTown.addTownListener(listener));\n      const newLocation = generateTestLocation();\n      const listenerRemoved = mockListeners[1];\n      testingTown.removeTownListener(listenerRemoved);\n      testingTown.updatePlayerLocation(player, newLocation);\n      expect(listenerRemoved.onPlayerMoved).not.toBeCalled();\n    });\n    it('should not notify removed listeners of player disconnections when destroySession is called', async () => {\n      const player = new Player('test player');\n      const session = await testingTown.addPlayer(player);\n\n      mockListeners.forEach(listener => testingTown.addTownListener(listener));\n      const listenerRemoved = mockListeners[1];\n      testingTown.removeTownListener(listenerRemoved);\n      testingTown.destroySession(session);\n      expect(listenerRemoved.onPlayerDisconnected).not.toBeCalled();\n    });\n    it('should not notify removed listeners of new players when addPlayer is called', async () => {\n      const player = new Player('test player');\n\n      mockListeners.forEach(listener => testingTown.addTownListener(listener));\n      const listenerRemoved = mockListeners[1];\n      testingTown.removeTownListener(listenerRemoved);\n      const session = await testingTown.addPlayer(player);\n      testingTown.destroySession(session);\n      expect(listenerRemoved.onPlayerJoined).not.toBeCalled();\n    });\n\n    it('should not notify removed listeners that the town is destroyed when disconnectAllPlayers is called', async () => {\n      const player = new Player('test player');\n      await testingTown.addPlayer(player);\n\n      mockListeners.forEach(listener => testingTown.addTownListener(listener));\n      const listenerRemoved = mockListeners[1];\n      testingTown.removeTownListener(listenerRemoved);\n      testingTown.disconnectAllPlayers();\n      expect(listenerRemoved.onTownDestroyed).not.toBeCalled();\n    });\n  });\n  describe('townSubscriptionHandler', () => {\n    const mockSocket = mock<Socket>();\n    let testingTown: CoveyTownController;\n    let player: Player;\n    let session: PlayerSession;\n    beforeEach(async () => {\n      const townName = `connectPlayerSocket tests ${nanoid()}`;\n      testingTown = CoveyTownsStore.getInstance().createTown(townName, false);\n      mockReset(mockSocket);\n      player = new Player('test player');\n      session = await testingTown.addPlayer(player);\n    });\n    it('should reject connections with invalid town IDs by calling disconnect', async () => {\n      TestUtils.setSessionTokenAndTownID(nanoid(), session.sessionToken, mockSocket);\n      townSubscriptionHandler(mockSocket);\n      expect(mockSocket.disconnect).toBeCalledWith(true);\n    });\n    it('should reject connections with invalid session tokens by calling disconnect', async () => {\n      TestUtils.setSessionTokenAndTownID(testingTown.coveyTownID, nanoid(), mockSocket);\n      townSubscriptionHandler(mockSocket);\n      expect(mockSocket.disconnect).toBeCalledWith(true);\n    });\n    describe('with a valid session token', () => {\n      it('should add a town listener, which should emit \"newPlayer\" to the socket when a player joins', async () => {\n        TestUtils.setSessionTokenAndTownID(\n          testingTown.coveyTownID,\n          session.sessionToken,\n          mockSocket,\n        );\n        townSubscriptionHandler(mockSocket);\n        await testingTown.addPlayer(player);\n        expect(mockSocket.emit).toBeCalledWith('newPlayer', player);\n      });\n      it('should add a town listener, which should emit \"playerMoved\" to the socket when a player moves', async () => {\n        TestUtils.setSessionTokenAndTownID(\n          testingTown.coveyTownID,\n          session.sessionToken,\n          mockSocket,\n        );\n        townSubscriptionHandler(mockSocket);\n        testingTown.updatePlayerLocation(player, generateTestLocation());\n        expect(mockSocket.emit).toBeCalledWith('playerMoved', player);\n      });\n      it('should add a town listener, which should emit \"playerDisconnect\" to the socket when a player disconnects', async () => {\n        TestUtils.setSessionTokenAndTownID(\n          testingTown.coveyTownID,\n          session.sessionToken,\n          mockSocket,\n        );\n        townSubscriptionHandler(mockSocket);\n        testingTown.destroySession(session);\n        expect(mockSocket.emit).toBeCalledWith('playerDisconnect', player);\n      });\n      it('should add a town listener, which should emit \"townClosing\" to the socket and disconnect it when disconnectAllPlayers is called', async () => {\n        TestUtils.setSessionTokenAndTownID(\n          testingTown.coveyTownID,\n          session.sessionToken,\n          mockSocket,\n        );\n        townSubscriptionHandler(mockSocket);\n        testingTown.disconnectAllPlayers();\n        expect(mockSocket.emit).toBeCalledWith('townClosing');\n        expect(mockSocket.disconnect).toBeCalledWith(true);\n      });\n      describe('when a socket disconnect event is fired', () => {\n        it('should remove the town listener for that socket, and stop sending events to it', async () => {\n          TestUtils.setSessionTokenAndTownID(\n            testingTown.coveyTownID,\n            session.sessionToken,\n            mockSocket,\n          );\n          townSubscriptionHandler(mockSocket);\n\n          // find the 'disconnect' event handler for the socket, which should have been registered after the socket was connected\n          const disconnectHandler = mockSocket.on.mock.calls.find(call => call[0] === 'disconnect');\n          if (disconnectHandler && disconnectHandler[1]) {\n            disconnectHandler[1]();\n            const newPlayer = new Player('should not be notified');\n            await testingTown.addPlayer(newPlayer);\n            expect(mockSocket.emit).not.toHaveBeenCalledWith('newPlayer', newPlayer);\n          } else {\n            fail('No disconnect handler registered');\n          }\n        });\n        it('should destroy the session corresponding to that socket', async () => {\n          TestUtils.setSessionTokenAndTownID(\n            testingTown.coveyTownID,\n            session.sessionToken,\n            mockSocket,\n          );\n          townSubscriptionHandler(mockSocket);\n\n          // find the 'disconnect' event handler for the socket, which should have been registered after the socket was connected\n          const disconnectHandler = mockSocket.on.mock.calls.find(call => call[0] === 'disconnect');\n          if (disconnectHandler && disconnectHandler[1]) {\n            disconnectHandler[1]();\n            mockReset(mockSocket);\n            TestUtils.setSessionTokenAndTownID(\n              testingTown.coveyTownID,\n              session.sessionToken,\n              mockSocket,\n            );\n            townSubscriptionHandler(mockSocket);\n            expect(mockSocket.disconnect).toHaveBeenCalledWith(true);\n          } else {\n            fail('No disconnect handler registered');\n          }\n        });\n      });\n      it('should forward playerMovement events from the socket to subscribed listeners', async () => {\n        TestUtils.setSessionTokenAndTownID(\n          testingTown.coveyTownID,\n          session.sessionToken,\n          mockSocket,\n        );\n        townSubscriptionHandler(mockSocket);\n        const mockListener = mock<CoveyTownListener>();\n        testingTown.addTownListener(mockListener);\n        // find the 'playerMovement' event handler for the socket, which should have been registered after the socket was connected\n        const playerMovementHandler = mockSocket.on.mock.calls.find(\n          call => call[0] === 'playerMovement',\n        );\n        if (playerMovementHandler && playerMovementHandler[1]) {\n          const newLocation = generateTestLocation();\n          player.location = newLocation;\n          playerMovementHandler[1](newLocation);\n          expect(mockListener.onPlayerMoved).toHaveBeenCalledWith(player);\n        } else {\n          fail('No playerMovement handler registered');\n        }\n      });\n    });\n  });\n\n  describe('addConversationArea', () => {\n    let testingTown: CoveyTownController;\n    beforeEach(() => {\n      const townName = `addConversationArea test town ${nanoid()}`;\n      testingTown = new CoveyTownController(townName, false);\n    });\n    it('should add the conversation area to the list of conversation areas', () => {\n      const newConversationArea = TestUtils.createConversationForTesting();\n      const result = testingTown.addConversationArea(newConversationArea);\n      expect(result).toBe(true);\n      const areas = testingTown.conversationAreas;\n      expect(areas.length).toEqual(1);\n      expect(areas[0].label).toEqual(newConversationArea.label);\n      expect(areas[0].topic).toEqual(newConversationArea.topic);\n      expect(areas[0].boundingBox).toEqual(newConversationArea.boundingBox);\n    });\n\n    // Represents the test case to check for all of the last buggy cases\n    it('Represents the test case to check for all of the last buggy cases', async () => {\n      const firstConversationArea = TestUtils.createConversationForTesting({\n        conversationLabel: 'newConversationArea1 Label',\n        conversationTopic: 'newConversationArea1 Topic',\n        boundingBox: { x: 5, y: 5, height: 50, width: 50 },\n      });\n\n      // Represents adding the conversation area into the list of areas and then checking with the invalid bounding boxes\n      // const areas = testingTown.conversationAreas;\n\n      // const mockListener = mock<CoveyTownListener>();\n      // Represents the array of mock listeners\n      const mockListeners = [mock<CoveyTownListener>()];\n      mockListeners.forEach(element => {\n        testingTown.addTownListener(element);\n      });\n      const newLocation: UserLocation = {\n        moving: false,\n        rotation: 'front',\n        x: 20,\n        y: 20,\n        conversationLabel: firstConversationArea.label,\n      };\n      const player = new Player('player');\n      const playerAdded = testingTown.addPlayer(player);\n      expect(playerAdded).toBeTruthy();\n      // Represents the test of when the player is not in the testing town\n      const playerMoved = testingTown.updatePlayerLocation(player, newLocation);\n      expect(playerMoved).toBeUndefined();\n    });\n\n    // Represents the test case to check for the boudning boxes\n    it('Represents the checking of the bounding boxes', async () => {\n      const firstConversationArea = TestUtils.createConversationForTesting({\n        conversationLabel: 'newConversationArea1 Label',\n        conversationTopic: 'newConversationArea1 Topic',\n        boundingBox: { x: 5, y: 5, height: 50, width: 50 },\n      });\n      const boundingConversationArea = TestUtils.createConversationForTesting({\n        conversationLabel: 'label of the conversation area',\n        conversationTopic: 'newConversationArea1 Topic 2',\n        boundingBox: { x: 10, y: 10, height: 50, width: 50 },\n      });\n      const secondConversationArea = TestUtils.createConversationForTesting({\n        conversationLabel: 'label of the conversation area',\n        conversationTopic: 'newConversationArea1 Topic 2',\n        boundingBox: { x: 40, y: 40, height: 5, width: 5 },\n      });\n\n      // Represents adding the conversation area into the list of areas and then checking with the invalid bounding boxes\n      const areas = testingTown.conversationAreas;\n\n      expect(areas.length).toBe(0);\n      const addFirst = testingTown.addConversationArea(firstConversationArea);\n      expect(addFirst).toBe(true);\n      expect(areas.length).toBe(1);\n      // Represents returning false since the bounding boxes overlap\n      const addBounding = testingTown.addConversationArea(boundingConversationArea);\n      expect(addBounding).not.toBeUndefined();\n      expect(addBounding).toBe(false);\n      expect(areas.length).toBe(1);\n\n      // const mockListener = mock<CoveyTownListener>();\n      // Represents the array of mock listeners\n      const mockListeners = [mock<CoveyTownListener>()];\n      mockListeners.forEach(element => {\n        testingTown.addTownListener(element);\n      });\n      const newLocation: UserLocation = {\n        moving: false,\n        rotation: 'front',\n        x: 20,\n        y: 20,\n        conversationLabel: firstConversationArea.label,\n      };\n\n      const addSecond = testingTown.addConversationArea(secondConversationArea);\n      expect(addSecond).toBe(true);\n      const player = new Player('player');\n      const playerAdded = await testingTown.addPlayer(player);\n      const playerToTest = new Player('Player to test');\n      const playerTest = await testingTown.addPlayer(playerToTest);\n      expect(playerTest).toBeTruthy();\n      expect(playerAdded).toBeTruthy();\n      const playerMoved = testingTown.updatePlayerLocation(player, newLocation);\n      expect(playerMoved).toBeUndefined();\n      expect(player.activeConversationArea?.label).toEqual(firstConversationArea.label);\n      expect(player.activeConversationArea?.topic).toEqual(firstConversationArea.topic);\n      expect(player.activeConversationArea?.boundingBox).toEqual(firstConversationArea.boundingBox);\n      expect(firstConversationArea.occupantsByID[0]).toEqual(player.id);\n      mockListeners.forEach(givenElement => {\n        expect(givenElement.onConversationAreaUpdated).toHaveBeenCalledWith(firstConversationArea);\n      });\n      mockListeners.forEach(givenElement => {\n        expect(givenElement.onPlayerMoved).toHaveBeenCalledWith(player);\n      });\n      // const locationConditionForX =\n      //   firstConversationArea.boundingBox.x - firstConversationArea.boundingBox.width / 2;\n      // const locationConditionForX1 =\n      //   firstConversationArea.boundingBox.x + firstConversationArea.boundingBox.width / 2;\n      // const locationConditionForY =\n      //   firstConversationArea.boundingBox.y - firstConversationArea.boundingBox.height / 2;\n      // const locationConditionForY1 =\n      //   firstConversationArea.boundingBox.y + firstConversationArea.boundingBox.height / 2;\n\n      expect(player.isWithin(firstConversationArea)).toBe(true);\n      // LEFT EDGE CHECK OF THE PLAYER\n      const leftEdge: UserLocation = {\n        moving: false,\n        rotation: 'front',\n        x: firstConversationArea.boundingBox.x - firstConversationArea.boundingBox.width / 2,\n        y: 20,\n        conversationLabel: firstConversationArea.label,\n      };\n      const playerMoveAgain = testingTown.updatePlayerLocation(player, leftEdge);\n      expect(playerMoveAgain).toBeUndefined();\n      expect(player.isWithin(firstConversationArea)).toBe(false);\n      // RIGHT EDGE CHECK OF THE PLAYER\n      const rightEdge: UserLocation = {\n        moving: false,\n        rotation: 'front',\n        x: firstConversationArea.boundingBox.x + firstConversationArea.boundingBox.width / 2,\n        y: 20,\n        conversationLabel: firstConversationArea.label,\n      };\n      const playerMoveRight = testingTown.updatePlayerLocation(player, rightEdge);\n      expect(playerMoveRight).toBeUndefined();\n      expect(player.isWithin(firstConversationArea)).toBe(false);\n      // UPPER EDGE CHECK OF THE PLAYER\n      const upperEdge: UserLocation = {\n        moving: false,\n        rotation: 'front',\n        x: 20,\n        y: firstConversationArea.boundingBox.y + firstConversationArea.boundingBox.height / 2,\n        conversationLabel: firstConversationArea.label,\n      };\n      const playerMoveUp = testingTown.updatePlayerLocation(player, upperEdge);\n      expect(playerMoveUp).toBeUndefined();\n      expect(player.isWithin(firstConversationArea)).toBe(false);\n      // LOWER EDGE CHECK OF THE PLAYER\n      const lowerEdge: UserLocation = {\n        moving: false,\n        rotation: 'front',\n        x: 20,\n        y: firstConversationArea.boundingBox.y - firstConversationArea.boundingBox.height / 2,\n        conversationLabel: firstConversationArea.label,\n      };\n      const playerMoveDown = testingTown.updatePlayerLocation(player, lowerEdge);\n      expect(playerMoveDown).toBeUndefined();\n      expect(player.isWithin(firstConversationArea)).toBe(false);\n      // OUTSIDE OF THE ENTIRE BOX CHECK OF THE PLAYER\n      const outerLocation: UserLocation = {\n        moving: false,\n        rotation: 'front',\n        x: 40,\n        y: 40,\n        conversationLabel: secondConversationArea.label,\n      };\n      // Represents the test case of when the player is moved to another location outside of the bounding box\n      const movePlayerOut = testingTown.updatePlayerLocation(player, outerLocation);\n      expect(movePlayerOut).toBeUndefined();\n      expect(player.isWithin(firstConversationArea)).toBe(false);\n      expect(player.isWithin(secondConversationArea)).toBe(true);\n    });\n\n    it('Represents the checking of the label edge cases', async () => {\n      const firstConversationArea = TestUtils.createConversationForTesting({\n        conversationLabel: 'newConversationArea1 Label',\n        conversationTopic: 'newConversationArea1 Topic',\n        boundingBox: { x: 10, y: 10, height: 5, width: 5 },\n      });\n      const withoutLabelConversationArea = TestUtils.createConversationForTesting({\n        conversationLabel: '',\n        conversationTopic: 'newConversationArea1 Topic',\n        boundingBox: { x: 30, y: 30, height: 5, width: 5 },\n      });\n      const invalidConv = TestUtils.createConversationForTesting({\n        conversationLabel: 'invalidConversation',\n        conversationTopic: 'invalid',\n        boundingBox: { x: 20, y: 20, height: 5, width: 5 },\n      });\n      const invalidConv2 = TestUtils.createConversationForTesting({\n        conversationLabel: 'invalidConversation',\n        conversationTopic: 'invalid',\n        boundingBox: { x: 20, y: 20, height: 5, width: 5 },\n      });\n      const invalidConv3 = TestUtils.createConversationForTesting({\n        conversationLabel: 'invalidConversation',\n        conversationTopic: 'invalid',\n        boundingBox: { x: 25, y: 25, height: 5, width: 5 },\n      });\n\n      const areas = testingTown.conversationAreas;\n      expect(areas.length).toEqual(0);\n      const addfirst = testingTown.addConversationArea(firstConversationArea);\n      expect(addfirst).toBe(true);\n      expect(areas[0].label).toEqual(firstConversationArea.label);\n      expect(areas[0].topic).toEqual(firstConversationArea.topic);\n      expect(areas[0].boundingBox).toEqual(firstConversationArea.boundingBox);\n      const addWithout = testingTown.addConversationArea(withoutLabelConversationArea);\n      expect(addWithout).toBe(true);\n      const addSecond = testingTown.addConversationArea(invalidConv);\n      expect(addSecond).toBe(true);\n\n      const addthird = testingTown.addConversationArea(invalidConv3);\n      expect(addthird).toBe(false);\n\n      const mockListener = mock<CoveyTownListener>();\n      // Represents the array of mock listeners\n      const mockListeners = [mock<CoveyTownListener>()];\n      mockListeners.forEach(element => {\n        testingTown.addTownListener(element);\n      });\n      expect(areas.length).toEqual(3);\n      const addInvalidLabel = testingTown.addConversationArea(invalidConv2);\n      expect(addInvalidLabel).toBe(false);\n      expect(mockListener.onConversationAreaUpdated).not.toBeCalledWith(invalidConv2);\n      const player = new Player('player');\n      const newLocation: UserLocation = {\n        moving: false,\n        rotation: 'front',\n        x: 20,\n        y: 15,\n        conversationLabel: invalidConv.label,\n      };\n      await testingTown.addPlayer(player);\n      const addPlayer = testingTown.updatePlayerLocation(player, newLocation);\n      expect(addPlayer).toBeUndefined();\n      expect(player.activeConversationArea).toEqual(invalidConv);\n      // Now, removing the player\n      expect(invalidConv.occupantsByID.length).toBe(1);\n      const removePlayer = testingTown.removePlayerFromConversationArea(player, invalidConv);\n      expect(removePlayer).toBeUndefined();\n      areas.splice(2);\n      expect(areas.length).toEqual(2);\n      // Now, we can add the conversation with the duplicate label\n      expect(testingTown.addConversationArea(invalidConv2)).toBe(true);\n      expect(areas.filter(element => element.label).length).toEqual(3);\n      expect(areas.findIndex(p => p.label === invalidConv.label)).toEqual(2);\n      expect(areas.find(conv => conv.label === invalidConv.label)).toEqual(invalidConv2);\n      expect(areas.find(conv => conv.label === invalidConv.label)).toBeTruthy();\n      areas.splice(2);\n      expect(areas.find(conv => conv.label === invalidConv.label)).toBeUndefined();\n      areas.splice(1);\n      areas.splice(0);\n      expect(areas.length).toEqual(0);\n      expect(areas.find(conv => conv.label === invalidConv.label)).toBeUndefined();\n      expect(areas.find(conv => conv.label === firstConversationArea.label)).toBeUndefined();\n    });\n    // Represents the checking of edge cases for the addConversationArea\n    it('Represents the checking of edge cases for the addConversationArea', async () => {\n      const firstConversationArea = TestUtils.createConversationForTesting({\n        conversationLabel: 'newConversationArea1 Label',\n        conversationTopic: 'newConversationArea1 Topic',\n        boundingBox: { x: 10, y: 10, height: 5, width: 5 },\n      });\n      const withoutLabelConversationArea = TestUtils.createConversationForTesting({\n        conversationLabel: '',\n        conversationTopic: 'newConversationArea1 Topic',\n        boundingBox: { x: 10, y: 10, height: 5, width: 5 },\n      });\n      const invalidConv = TestUtils.createConversationForTesting({\n        conversationLabel: 'invalidConversation',\n        conversationTopic: 'invalid',\n        boundingBox: { x: 20, y: 20, height: 10, width: 10 },\n      });\n      const invalidConv2 = TestUtils.createConversationForTesting({\n        conversationLabel: 'invalidConversation',\n        conversationTopic: 'invalid',\n        boundingBox: { x: 10, y: 10, height: 5, width: 5 },\n      });\n      const newLocation: UserLocation = {\n        moving: false,\n        rotation: 'front',\n        x: 20,\n        y: 20,\n        conversationLabel: invalidConv.label,\n      };\n      const areas = testingTown.conversationAreas;\n      const player = new Player('player');\n      await testingTown.addPlayer(player);\n\n      const addThisConversation = testingTown.addConversationArea(firstConversationArea);\n      const playerMove = testingTown.updatePlayerLocation(player, newLocation);\n      expect(playerMove).toBeUndefined();\n      expect(player.activeConversationArea).toBeUndefined();\n      const addwithoutLabel = testingTown.addConversationArea(withoutLabelConversationArea);\n      const addinvalid = testingTown.addConversationArea(invalidConv);\n      expect(\n        testingTown.addConversationArea({\n          label: 'newConversationArea1 Label',\n          topic: 'given new conv',\n          occupantsByID: [],\n          boundingBox: { x: 20, y: 20, height: 10, width: 5 },\n        }),\n      ).toBe(false);\n      expect(\n        testingTown.addConversationArea({\n          label: 'new valid area',\n          topic: 'new valid topic',\n          occupantsByID: [],\n          boundingBox: { x: 30, y: 30, height: 5, width: 5 },\n        }),\n      ).toBe(true);\n\n      expect(addThisConversation).toBe(true);\n      expect(addwithoutLabel).toBe(false);\n      expect(addinvalid).toBe(true);\n      expect(player.activeConversationArea).toEqual(invalidConv);\n\n      // Represent the check to add the conversation label with the same label\n      const sameLabelAdded = testingTown.addConversationArea(invalidConv2);\n      expect(sameLabelAdded).toBe(false);\n      expect(areas).not.toContain(invalidConv2);\n\n      const mockListener = mock<CoveyTownListener>();\n      // Represents the array of mock listeners\n      const mockListeners = [mock<CoveyTownListener>()];\n      mockListeners.forEach(element => {\n        testingTown.addTownListener(element);\n      });\n      mockListeners.push(mockListener);\n      testingTown.addTownListener(mockListener);\n\n      expect(mockListener.onConversationAreaUpdated).toHaveBeenCalledTimes(0);\n      expect(mockListener.onPlayerMoved).toHaveBeenCalledTimes(0);\n      mockListeners.forEach(givenElement => {\n        expect(givenElement.onConversationAreaUpdated).not.toHaveBeenCalledWith(invalidConv);\n      });\n      mockListeners.forEach(givenElement => {\n        expect(givenElement.onPlayerMoved).toHaveBeenCalledTimes(0);\n      });\n    });\n\n    // Represents the adding of players and conversation areas that are invalid\n    it('Represents the adding of players and conversation areas that are invalid ', async () => {\n      const firstConversationArea = {\n        label: 'newConversationArea1 Label',\n        topic: 'newConversationArea1 Topic',\n        occupantsByID: [],\n        boundingBox: { x: 10, y: 10, height: 5, width: 5 },\n      };\n      const withoutLabelConversationArea = {\n        label: '',\n        topic: 'newConversationArea1 Topic',\n        occupantsByID: [],\n        boundingBox: { x: 10, y: 10, height: 5, width: 5 },\n      };\n      const secondConversationArea = {\n        label: 'second',\n        topic: 'second',\n        occupantsByID: [],\n        boundingBox: { x: 10, y: 10, height: 5, width: 5 },\n      };\n      const invalidConv = {\n        label: 'invalidConversation',\n        topic: 'invalid',\n        occupantsByID: [],\n        boundingBox: { x: 20, y: 20, height: 10, width: 5 },\n      };\n      const invalidConv2 = {\n        label: 'invalidConversation',\n        topic: 'invalid',\n        occupantsByID: [],\n        boundingBox: { x: 10, y: 10, height: 5, width: 5 },\n      };\n      const addThisConversation = testingTown.addConversationArea(firstConversationArea);\n      const withoutLabel = testingTown.addConversationArea(withoutLabelConversationArea);\n      const secondLabel = testingTown.addConversationArea(secondConversationArea);\n      expect(addThisConversation).toBe(true);\n      expect(withoutLabel).toBe(false);\n      expect(secondLabel).toBe(false);\n\n      const newLocation: UserLocation = {\n        moving: false,\n        rotation: 'front',\n        x: 30,\n        y: 30,\n        conversationLabel: firstConversationArea.label,\n      };\n      // Represents a player to be moved into an invalid conversation area\n      const player = new Player('player to be added');\n      testingTown.addPlayer(player);\n      // Represents the invalid player\n      const playerInvalid = new Player('');\n\n      const mockListener = mock<CoveyTownListener>();\n      // Represents the array of mock listeners\n      const mockListeners = [mock<CoveyTownListener>()];\n      mockListeners.forEach(element => {\n        testingTown.addTownListener(element);\n      });\n      mockListeners.push(mockListener);\n      testingTown.addTownListener(mockListener);\n      // Represents adding a player into the invalid conversation area and the emitter not being called\n      testingTown.updatePlayerLocation(player, newLocation);\n      expect(mockListener.onConversationAreaUpdated).toHaveBeenCalledWith(firstConversationArea);\n      testingTown.updatePlayerLocation(playerInvalid, newLocation);\n      expect(mockListener.onConversationAreaUpdated).toHaveBeenCalledTimes(2);\n\n      // Represents an invalid conversation area\n      const invalidConversation = {\n        label: '',\n        topic: '',\n        occupantsByID: [],\n        boundingBox: { x: 10, y: 10, height: 5, width: 5 },\n      };\n      const invalidity = testingTown.addConversationArea(invalidConversation);\n      expect(invalidity).toBe(false);\n\n      const invalidLocation: UserLocation = {\n        moving: false,\n        rotation: 'front',\n        x: 30,\n        y: 30,\n        conversationLabel: invalidConv.label,\n      };\n\n      // Represents adding the player into an invalid location\n      testingTown.updatePlayerLocation(player, invalidLocation);\n      expect(mockListener.onConversationAreaUpdated).not.toBeCalledWith(invalidLocation);\n      expect(mockListener.onConversationAreaUpdated).toBeCalledTimes(3);\n      mockListeners.forEach(givenElement => {\n        expect(givenElement.onConversationAreaUpdated).not.toHaveBeenCalledWith(\n          invalidConversation,\n        );\n      });\n\n      const areas = testingTown.conversationAreas;\n      expect(areas.length).toEqual(1);\n      // Represents adding the conversation into the town\n      const isItAdded = testingTown.addConversationArea(invalidConv);\n      expect(isItAdded).toBe(true);\n      expect(areas.length).toEqual(2);\n      expect(mockListener.onConversationAreaUpdated).toHaveBeenCalledWith(invalidConv);\n\n      // Represents adding the player into this conversation area\n      expect(invalidConv.occupantsByID.length).toEqual(0);\n      const addPlayerToThis = testingTown.updatePlayerLocation(player, invalidLocation);\n      expect(addPlayerToThis).toBeUndefined();\n      expect(invalidConv.occupantsByID.length).toBe(1);\n      expect(mockListener.onConversationAreaUpdated).toBeCalledWith(invalidConv);\n      mockListeners.forEach(givenElement => {\n        expect(givenElement.onConversationAreaUpdated).toHaveBeenCalledWith(invalidConv);\n      });\n      expect(firstConversationArea.occupantsByID.length).toEqual(1);\n      expect(testingTown.addConversationArea(invalidConv2)).toBe(false);\n      expect(mockListener.onConversationAreaUpdated).not.toHaveBeenCalledWith(invalidConv2);\n    });\n\n    // Represents the case of checking for the number of conversation areas, whether they are valid and can be added\n    it('Represents the case of checking for the number of conversation areas, whether they are valid and can be added  ', async () => {\n      const firstConversationArea = TestUtils.createConversationForTesting({\n        conversationLabel: 'newConversationArea1 Label',\n        conversationTopic: 'newConversationArea1 Topic',\n        boundingBox: { x: 10, y: 10, height: 5, width: 5 },\n      });\n      const secondConversationArea = TestUtils.createConversationForTesting({\n        conversationLabel: 'prev Label',\n        conversationTopic: 'prev Topic',\n        boundingBox: { x: 20, y: 20, height: 10, width: 10 },\n      });\n      const thirdConversationArea = TestUtils.createConversationForTesting({\n        conversationLabel: 'prev Label',\n        conversationTopic: '',\n        boundingBox: { x: 20, y: 20, height: 10, width: 10 },\n      });\n      const noTopicConversationArea = TestUtils.createConversationForTesting({\n        conversationLabel: 'no topic label',\n        conversationTopic: '',\n        boundingBox: { x: 20, y: 20, height: 10, width: 10 },\n      });\n      const overlappingConvArea = TestUtils.createConversationForTesting({\n        conversationLabel: 'Overlaps',\n        conversationTopic: 'overlaps',\n        boundingBox: { x: 25, y: 25, height: 15, width: 15 },\n      });\n      const conversationAreaToBeAdded = TestUtils.createConversationForTesting({\n        conversationLabel: 'conversation',\n        conversationTopic: 'conversationarea',\n        boundingBox: { x: 30, y: 30, height: 10, width: 10 },\n      });\n      const result = testingTown.addConversationArea(secondConversationArea);\n      expect(result).toBe(true);\n\n      const mockListener = mock<CoveyTownListener>();\n      // Represents the array of mock listeners\n      const mockListeners = [mock<CoveyTownListener>()];\n      mockListeners.forEach(element => {\n        testingTown.addTownListener(element);\n      });\n      mockListeners.push(mockListener);\n      testingTown.addTownListener(mockListener);\n      // Represents an invalid conversation area\n      const invalidArea = TestUtils.createConversationForTesting({\n        conversationLabel: '',\n        conversationTopic: '',\n        boundingBox: { x: 10, y: 10, height: 5, width: 5 },\n      });\n\n      const invalid = testingTown.addConversationArea({\n        label: '',\n        topic: '',\n        occupantsByID: [],\n        boundingBox: { x: 10, y: 10, height: 5, width: 5 },\n      });\n      expect(invalid).toBe(false);\n      expect(invalidArea.topic).toBeTruthy();\n\n      const player = new Player('player');\n      const newLocation: UserLocation = {\n        moving: false,\n        rotation: 'front',\n        x: 30,\n        y: 30,\n        conversationLabel: conversationAreaToBeAdded.label,\n      };\n\n      // Represents intitializing the players in order to check for the functionalities of the addConversationArea function\n      const player1 = new Player('Player 1');\n      const player2 = new Player('Player 2');\n      const player3 = new Player('Player 3');\n      const player4 = new Player('Player 4');\n      const player5 = new Player('Player 5');\n\n      // // Represents the conversation areas returned\n      // const areas = testingTown.conversationAreas;\n      // Represents the test to check if a conversation area with a same label is added into the testing town\n      const checkLabelInvalid = testingTown.addConversationArea(thirdConversationArea);\n      expect(checkLabelInvalid).toBe(false);\n\n      // This cannot be added since the bounding boxes of this and the secondConversation areas are the same\n      const checkValidLabel = testingTown.addConversationArea(firstConversationArea);\n      expect(checkValidLabel).toBe(true);\n\n      const checkResult = testingTown.addConversationArea(noTopicConversationArea);\n      expect(checkResult).toBe(false);\n\n      // Represents the attempt to add a conversation area when there is no topic, in the case of which, it should return false\n      const overlappingBoundingBox = testingTown.addConversationArea(overlappingConvArea);\n      expect(overlappingBoundingBox).toBe(false);\n\n      // Represents the areas in the town\n      const areas = testingTown.conversationAreas;\n      expect(areas.length).toEqual(2);\n      const checkIfEnter = testingTown.addConversationArea(conversationAreaToBeAdded);\n      testingTown.updatePlayerLocation(player, newLocation);\n      testingTown.updatePlayerLocation(player1, newLocation);\n      testingTown.updatePlayerLocation(player2, newLocation);\n      testingTown.updatePlayerLocation(player3, newLocation);\n      testingTown.updatePlayerLocation(player4, newLocation);\n      testingTown.updatePlayerLocation(player5, newLocation);\n      expect(checkIfEnter).toBe(true);\n      expect(areas.length).toEqual(3);\n      expect(player1.isWithin(conversationAreaToBeAdded)).toBe(true);\n      expect(player2.isWithin(conversationAreaToBeAdded)).toBe(true);\n      expect(player3.isWithin(conversationAreaToBeAdded)).toBe(true);\n      expect(player4.isWithin(conversationAreaToBeAdded)).toBe(true);\n      expect(player5.isWithin(conversationAreaToBeAdded)).toBe(true);\n      // --------- X --------------\n      expect(player1.activeConversationArea).toBe(conversationAreaToBeAdded);\n      expect(player2.activeConversationArea).toBe(conversationAreaToBeAdded);\n      expect(player3.activeConversationArea).toBe(conversationAreaToBeAdded);\n      expect(player4.activeConversationArea).toBe(conversationAreaToBeAdded);\n      expect(player5.activeConversationArea).toBe(conversationAreaToBeAdded);\n      // ------ Checking the occupant id list ---------\n      expect(conversationAreaToBeAdded.occupantsByID.length).toEqual(6);\n      expect(conversationAreaToBeAdded.occupantsByID[0]).toEqual(player.id);\n      expect(conversationAreaToBeAdded.occupantsByID[1]).toEqual(player1.id);\n      expect(conversationAreaToBeAdded.occupantsByID[2]).toEqual(player2.id);\n      expect(conversationAreaToBeAdded.occupantsByID[3]).toEqual(player3.id);\n      expect(conversationAreaToBeAdded.occupantsByID[4]).toEqual(player4.id);\n      expect(conversationAreaToBeAdded.occupantsByID[5]).toEqual(player5.id);\n      mockListeners.forEach(givenElement => {\n        expect(givenElement.onConversationAreaUpdated).toHaveBeenCalledWith(\n          conversationAreaToBeAdded,\n        );\n      });\n\n      expect(player.isWithin(conversationAreaToBeAdded)).toBe(true);\n      expect(player.activeConversationArea).toEqual(conversationAreaToBeAdded);\n      expect(player.activeConversationArea?.occupantsByID[0]).toEqual(\n        conversationAreaToBeAdded.occupantsByID[0],\n      );\n    });\n\n    // Represents the edge cases to be checked throughout the addConversation area function\n    it('Represents the edge cases to be checked throughout the addConversation area function', async () => {\n      // Represents creating an invalid conversation area to be added to the testing town\n      const firstConversationArea = TestUtils.createConversationForTesting({\n        conversationLabel: 'givenfirsttopic',\n        conversationTopic: 'conversations are good',\n        boundingBox: { x: 20, y: 20, height: 10, width: 10 },\n      });\n      // Represents a conversation area which when added, will have the bounding boxes overlap, in the case of which, the conversation\n      // area will not be added to the testing town\n      const overlappingConversationArea = TestUtils.createConversationForTesting({\n        conversationLabel: 'prev Label',\n        conversationTopic: 'prev Topic',\n        boundingBox: { x: 40, y: 40, height: 100, width: 100 },\n      });\n      const secondConversationArea = TestUtils.createConversationForTesting({\n        conversationLabel: 'secondLabel',\n        conversationTopic: 'Topic',\n        boundingBox: { x: 50, y: 50, height: 20, width: 30 },\n      });\n      // Represents an invalid conversation area which cannot be added\n\n      // Represents an undefined conversationarea\n      const undefinedArea = TestUtils.createConversationForTesting({});\n      const invalidAddArea = TestUtils.createConversationForTesting({\n        conversationLabel: 'This is an invalid area',\n        conversationTopic: '',\n        boundingBox: { x: 50, y: 50, height: 20, width: 30 },\n      });\n\n      // Represents adding an invalid area into a town\n      const invalidResult = testingTown.addConversationArea(invalidAddArea);\n      expect(invalidResult).toBe(true); // -------CHECK THIS LINE\n\n      const result = testingTown.addConversationArea(firstConversationArea);\n      expect(result).toBe(true);\n      // Represents the case of when an overlapping conversation area is added\n      const overlapResult = testingTown.addConversationArea(overlappingConversationArea);\n      expect(overlapResult).toBe(false);\n      // Represents the case of adding a valid conversation area in the testing town in the case of which it will be returning true\n      const validResult = testingTown.addConversationArea(secondConversationArea);\n      expect(validResult).toBe(false);\n      // Check for the undefined case\n\n      const mockListener = mock<CoveyTownListener>();\n      // Represents the array of mock listeners\n      const mockListeners = [mock<CoveyTownListener>()];\n      mockListeners.forEach(element => {\n        testingTown.addTownListener(element);\n      });\n      mockListeners.push(mockListener);\n      testingTown.addTownListener(mockListener);\n      const player = new Player(nanoid());\n      await testingTown.addPlayer(player);\n      const newLocation: UserLocation = {\n        moving: false,\n        rotation: 'front',\n        x: 25,\n        y: 25,\n        conversationLabel: firstConversationArea.label,\n      };\n      const undefinedLocation: UserLocation = {\n        moving: false,\n        rotation: 'front',\n        x: 25,\n        y: 25,\n        conversationLabel: undefinedArea.label,\n      };\n      testingTown.updatePlayerLocation(player, newLocation);\n\n      // const areas = testingTown.conversationAreas;\n      // Represents the player having the new conversation area added as the active conversation area\n      expect(player.activeConversationArea).toEqual(firstConversationArea);\n      expect(player.activeConversationArea?.occupantsByID[0]).toEqual(\n        firstConversationArea.occupantsByID[0],\n      );\n      expect(player.activeConversationArea?.topic).toEqual(firstConversationArea.topic);\n      expect(player.activeConversationArea?.label).toEqual(firstConversationArea.label);\n      mockListeners.forEach(givenElement => {\n        expect(givenElement.onConversationAreaUpdated).toHaveBeenCalledWith(firstConversationArea);\n      });\n\n      const areas = testingTown.conversationAreas;\n\n      // Represents when an undefined conversation are is given in the case of which the player wont be moved and it should return false\n      const moveInvalid = testingTown.addConversationArea(undefinedArea);\n      expect(moveInvalid).toBe(true);\n      testingTown.updatePlayerLocation(player, undefinedLocation);\n      expect(mockListener.onConversationAreaUpdated).toHaveBeenCalledWith(undefinedArea);\n      expect(mockListener.onConversationAreaUpdated).toHaveBeenCalledTimes(3);\n\n      expect(areas.length).toEqual(2);\n      expect(areas).toContain(undefinedArea);\n      expect(areas).toContain(invalidAddArea);\n      expect(\n        testingTown.addConversationArea({\n          label: '',\n          topic: '',\n          occupantsByID: [],\n          boundingBox: { x: 50, y: 50, height: 20, width: 30 },\n        }),\n      ).toBeFalsy();\n    });\n  });\n\n  describe('updatePlayerLocation', () => {\n    let testingTown: CoveyTownController;\n    beforeEach(() => {\n      const townName = `updatePlayerLocation test town ${nanoid()}`;\n      testingTown = new CoveyTownController(townName, false);\n    });\n    it(\"should respect the conversation area reported by the player userLocation.conversationLabel, and not override it based on the player's x,y location\", async () => {\n      const newConversationArea = TestUtils.createConversationForTesting({\n        boundingBox: { x: 10, y: 10, height: 5, width: 5 },\n      });\n      const result = testingTown.addConversationArea(newConversationArea);\n      expect(result).toBe(true);\n      const player = new Player(nanoid());\n      await testingTown.addPlayer(player);\n\n      const newLocation: UserLocation = {\n        moving: false,\n        rotation: 'front',\n        x: 25,\n        y: 25,\n        conversationLabel: newConversationArea.label,\n      };\n      testingTown.updatePlayerLocation(player, newLocation);\n      expect(player.activeConversationArea?.label).toEqual(newConversationArea.label);\n      expect(player.activeConversationArea?.topic).toEqual(newConversationArea.topic);\n      expect(player.activeConversationArea?.boundingBox).toEqual(newConversationArea.boundingBox);\n\n      const areas = testingTown.conversationAreas;\n      expect(areas[0].occupantsByID.length).toBe(1);\n      expect(areas[0].occupantsByID[0]).toBe(player.id);\n    });\n    it('should check for the index mutation of the player when the player has been removed from the given index', async () => {\n      const newConversationArea = TestUtils.createConversationForTesting({\n        boundingBox: { x: 10, y: 10, height: 5, width: 5 },\n      });\n      const result = testingTown.addConversationArea(newConversationArea);\n      expect(result).toBe(true);\n      const player1 = new Player('player 1');\n      const player2 = new Player('player 1');\n      const player3 = new Player('player 1');\n      await testingTown.addPlayer(player1);\n      await testingTown.addPlayer(player2);\n      await testingTown.addPlayer(player3);\n\n      const newLocation: UserLocation = {\n        moving: false,\n        rotation: 'front',\n        x: 25,\n        y: 25,\n        conversationLabel: newConversationArea.label,\n      };\n      testingTown.updatePlayerLocation(player1, newLocation);\n      testingTown.updatePlayerLocation(player2, newLocation);\n      testingTown.updatePlayerLocation(player3, newLocation);\n      expect(player1.activeConversationArea?.label).toEqual(newConversationArea.label);\n      expect(player1.activeConversationArea?.topic).toEqual(newConversationArea.topic);\n      expect(player1.activeConversationArea?.boundingBox).toEqual(newConversationArea.boundingBox);\n      expect(player2.activeConversationArea?.label).toEqual(newConversationArea.label);\n      expect(player2.activeConversationArea?.topic).toEqual(newConversationArea.topic);\n      expect(player2.activeConversationArea?.boundingBox).toEqual(newConversationArea.boundingBox);\n      expect(player3.activeConversationArea?.label).toEqual(newConversationArea.label);\n      expect(player3.activeConversationArea?.topic).toEqual(newConversationArea.topic);\n      expect(player3.activeConversationArea?.boundingBox).toEqual(newConversationArea.boundingBox);\n\n      const areas = testingTown.conversationAreas;\n      expect(areas[0].occupantsByID.length).toBe(3);\n      expect(areas[0].occupantsByID[0]).toBe(player1.id);\n      expect(areas[0].occupantsByID[1]).toBe(player2.id);\n      expect(areas[0].occupantsByID[2]).toBe(player3.id);\n      // Represents removing player 2 from the conversation area\n      testingTown.removePlayerFromConversationArea(player2, newConversationArea);\n      expect(newConversationArea.occupantsByID).toContain(player1.id);\n      expect(newConversationArea.occupantsByID).toContain(player3.id);\n    });\n    it('should emit an onConversationUpdated event when a conversation area gets a new occupant', async () => {\n      const newConversationArea = TestUtils.createConversationForTesting({\n        boundingBox: { x: 10, y: 10, height: 5, width: 5 },\n      });\n      const result = testingTown.addConversationArea(newConversationArea);\n      expect(result).toBe(true);\n\n      const mockListener = mock<CoveyTownListener>();\n      testingTown.addTownListener(mockListener);\n\n      const player = new Player(nanoid());\n      await testingTown.addPlayer(player);\n      const newLocation: UserLocation = {\n        moving: false,\n        rotation: 'front',\n        x: 25,\n        y: 25,\n        conversationLabel: newConversationArea.label,\n      };\n      testingTown.updatePlayerLocation(player, newLocation);\n      expect(mockListener.onConversationAreaUpdated).toHaveBeenCalledTimes(1);\n    });\n\n    // Represents the case of checking the entire remove helper function(additional tests)\n    it('Represents the case of checking the entire remove helper function(additional tests)', async () => {\n      const newConversationArea = TestUtils.createConversationForTesting({\n        conversationLabel: 'newConversationArea1 Label',\n        conversationTopic: 'newConversationArea1 Topic',\n        boundingBox: { x: 20, y: 20, height: 10, width: 10 },\n      });\n      const prevConversationArea1 = {\n        label: 'label',\n        topic: 'topic',\n        occupantsByID: [],\n        boundingBox: { x: 10, y: 10, height: 5, width: 5 },\n      };\n      const prevConversationArea2 = {\n        label: 'label1',\n        topic: 'topic1',\n        occupantsByID: [],\n        boundingBox: { x: 10, y: 10, height: 5, width: 5 },\n      };\n\n      const result = testingTown.addConversationArea(newConversationArea);\n\n      // Represents adding the previous active location from the conversation area of the player to the testing town to be tested\n      const resultPreviousLocation = testingTown.addConversationArea(prevConversationArea1);\n      const resultPreviousLocation1 = testingTown.addConversationArea(prevConversationArea2);\n\n      expect(result).toBe(true);\n      expect(resultPreviousLocation).toBe(true);\n      expect(resultPreviousLocation1).toBe(false);\n\n      const player = new Player('Player 1');\n      const playerCheckEdgeCase = new Player('player');\n      const playerCheckEdgeCase2 = new Player('player1');\n\n      await testingTown.addPlayer(player);\n      await testingTown.addPlayer(playerCheckEdgeCase);\n      await testingTown.addPlayer(playerCheckEdgeCase2);\n\n      const mockListener = mock<CoveyTownListener>();\n      // Represents the array of mock listeners\n      const mockListeners = [mock<CoveyTownListener>()];\n      mockListeners.forEach(element => {\n        testingTown.addTownListener(element);\n      });\n      mockListeners.push(mockListener);\n      testingTown.addTownListener(mockListener);\n      const newLocation: UserLocation = {\n        moving: false,\n        rotation: 'front',\n        x: 30,\n        y: 30,\n        conversationLabel: newConversationArea.label,\n      };\n\n      // Represents adding two players into a conversation area\n      const add1 = testingTown.updatePlayerLocation(player, newLocation);\n      const addSecond = testingTown.updatePlayerLocation(playerCheckEdgeCase, newLocation);\n      expect(add1).toBeUndefined();\n      expect(addSecond).toBeUndefined();\n      expect(player.activeConversationArea).toEqual(newConversationArea);\n      expect(playerCheckEdgeCase.activeConversationArea).toEqual(newConversationArea);\n      expect(player.activeConversationArea?.occupantsByID.length).toEqual(\n        newConversationArea.occupantsByID.length,\n      );\n      expect(playerCheckEdgeCase.activeConversationArea?.occupantsByID.length).toEqual(\n        newConversationArea.occupantsByID.length,\n      );\n      expect(player.id).toEqual(newConversationArea.occupantsByID[0]);\n      expect(playerCheckEdgeCase.id).toEqual(newConversationArea.occupantsByID[1]);\n      expect(mockListener.onPlayerMoved).toHaveBeenCalledTimes(2);\n      expect(mockListener.onConversationAreaUpdated).toHaveBeenCalledWith(newConversationArea);\n      // Represents removing the second added player from the conversation area now\n      const removeCheckEdgePlayer = testingTown.removePlayerFromConversationArea(\n        playerCheckEdgeCase,\n        newConversationArea,\n      );\n      expect(removeCheckEdgePlayer).toBeUndefined();\n      // Now, check for the presence in the occupants id list in the conversation area\n      expect(playerCheckEdgeCase.id).not.toEqual(newConversationArea.occupantsByID[1]);\n      expect(newConversationArea.occupantsByID).not.toContain(playerCheckEdgeCase.id);\n      expect(newConversationArea.occupantsByID).toContain(player.id);\n      mockListeners.forEach(givenElement => {\n        expect(givenElement.onConversationAreaUpdated).toHaveBeenCalledTimes(3);\n      });\n      mockListeners.forEach(givenElement => {\n        expect(givenElement.onConversationAreaDestroyed).toHaveBeenCalledTimes(0);\n      });\n      mockListeners.forEach(givenElement => {\n        expect(givenElement.onConversationAreaDestroyed).not.toHaveBeenCalledWith(\n          newConversationArea,\n        );\n      });\n      // One player removed - length decreased to 1\n      expect(newConversationArea.occupantsByID.length).toEqual(1);\n      const playerRemoved = testingTown.removePlayerFromConversationArea(\n        player,\n        newConversationArea,\n      );\n      expect(playerRemoved).toBeUndefined();\n      // Now, check for the presence in the occupants id list in the conversation area\n      expect(player.id).not.toEqual(newConversationArea.occupantsByID[0]);\n      mockListeners.forEach(givenElement => {\n        expect(givenElement.onConversationAreaUpdated).toHaveBeenCalledTimes(3);\n      });\n      mockListeners.forEach(givenElement => {\n        expect(givenElement.onConversationAreaDestroyed).toHaveBeenCalledTimes(1);\n      });\n      mockListeners.forEach(givenElement => {\n        expect(givenElement.onConversationAreaDestroyed).toHaveBeenCalledWith(newConversationArea);\n      });\n      // Another player removed - length decreased to 0\n      expect(newConversationArea.occupantsByID.length).toEqual(0);\n      // Now, we will try to remove a player from a conversation area that does not have any players\n      const removeLastPlayer = testingTown.removePlayerFromConversationArea(\n        playerCheckEdgeCase2,\n        newConversationArea,\n      );\n      expect(removeLastPlayer).toBeUndefined();\n      expect(newConversationArea.occupantsByID.findIndex(p => p === playerCheckEdgeCase2.id)).toBe(\n        -1,\n      );\n    });\n\n    // Represents the case of checking the edge case of when a player can be removed\n    it('Represents the case of checking the edge case of when a player can be removed', async () => {\n      const newConversationArea = TestUtils.createConversationForTesting({\n        conversationLabel: 'newConversationArea1 Label',\n        conversationTopic: 'newConversationArea1 Topic',\n        boundingBox: { x: 30, y: 30, height: 20, width: 20 },\n      });\n      const prevConversationArea = {\n        label: 'label',\n        topic: 'topic',\n        occupantsByID: [],\n        boundingBox: { x: 10, y: 10, height: 5, width: 5 },\n      };\n      const result = testingTown.addConversationArea(newConversationArea);\n      // Represents adding the previous active location from the conversation area of the player to the testing town to be tested\n      const resultPreviousLocation = testingTown.addConversationArea(prevConversationArea);\n      expect(result).toBe(true);\n      expect(resultPreviousLocation).toBe(true);\n\n      const player = new Player('Player 1');\n      const playerCheckEdgeCase = new Player('player');\n\n      const mockListener = mock<CoveyTownListener>();\n      // Represents the array of mock listeners\n      const mockListeners = [mock<CoveyTownListener>()];\n      mockListeners.forEach(element => {\n        testingTown.addTownListener(element);\n      });\n      mockListeners.push(mockListener);\n      testingTown.addTownListener(mockListener);\n      const newLocation: UserLocation = {\n        moving: false,\n        rotation: 'front',\n        x: 30,\n        y: 30,\n        conversationLabel: newConversationArea.label,\n      };\n      // Represents removing a player from a conversation area with an empty occupant ID list\n      const removeAttempt = testingTown.removePlayerFromConversationArea(\n        player,\n        prevConversationArea,\n      );\n      expect(removeAttempt).toBeFalsy();\n      expect(mockListener.onConversationAreaUpdated(prevConversationArea)).toBeUndefined();\n      expect(mockListener.onConversationAreaDestroyed(prevConversationArea)).toBeUndefined();\n      expect(mockListener.onPlayerMoved).not.toHaveBeenCalledWith(player);\n      // Represents adding the player into the new conversation area\n      const addAttempt = testingTown.updatePlayerLocation(playerCheckEdgeCase, newLocation);\n      expect(addAttempt).toBeUndefined();\n      expect(playerCheckEdgeCase.activeConversationArea).toEqual(newConversationArea);\n      expect(newConversationArea.occupantsByID[0]).toEqual(playerCheckEdgeCase.id);\n      // Now, we will remove this player\n      const removeAttemptFromValidArea = testingTown.removePlayerFromConversationArea(\n        playerCheckEdgeCase,\n        newConversationArea,\n      );\n      expect(removeAttemptFromValidArea).toBeUndefined();\n      expect(newConversationArea.occupantsByID[0]).not.toEqual(playerCheckEdgeCase.id);\n      expect(\n        newConversationArea.occupantsByID.splice(\n          newConversationArea.occupantsByID.findIndex(p => p === player.id),\n          1,\n        ),\n      ).toEqual([]);\n      const playerAdded = testingTown.updatePlayerLocation(player, newLocation);\n      expect(playerAdded).toBeUndefined();\n      // expect(player.activeConversationArea).toEqual(newConversationArea);\n    });\n    // Represents the case of checking the first part of the code when we are checking for the conversation area validity\n    it('Represents the case of checking the first part of the code when we are checking for the conversation area validity', async () => {\n      const newConversationArea = TestUtils.createConversationForTesting({\n        conversationLabel: 'newConversationArea1 Label',\n        conversationTopic: 'newConversationArea1 Topic',\n        boundingBox: { x: 10, y: 10, height: 5, width: 5 },\n      });\n      const prevConversationArea = TestUtils.createConversationForTesting({\n        conversationLabel: 'prev Label',\n        conversationTopic: 'prev Topic',\n        boundingBox: { x: 20, y: 20, height: 10, width: 10 },\n      });\n      const result = testingTown.addConversationArea(newConversationArea);\n      // Represents adding the previous active location from the conversation area of the player to the testing town to be tested\n      const resultPreviousLocation = testingTown.addConversationArea(prevConversationArea);\n      expect(result).toBe(true);\n      expect(resultPreviousLocation).toBe(true);\n\n      const player = new Player('Player 1');\n\n      const mockListener = mock<CoveyTownListener>();\n      // Represents the array of mock listeners\n      const mockListeners = [mock<CoveyTownListener>()];\n      mockListeners.forEach(element => {\n        testingTown.addTownListener(element);\n      });\n      testingTown.addTownListener(mockListener);\n      const newLocation: UserLocation = {\n        moving: false,\n        rotation: 'front',\n        x: 25,\n        y: 25,\n        conversationLabel: newConversationArea.label,\n      };\n      // Represents another location instance created\n      const newSecondLocation: UserLocation = {\n        moving: false,\n        rotation: 'front',\n        x: 25,\n        y: 25,\n        conversationLabel: prevConversationArea.label,\n      };\n      // Represents invalid location instance created\n      const invalidLocation: UserLocation = {\n        moving: false,\n        rotation: 'front',\n        x: 25,\n        y: 25,\n        conversationLabel: '',\n      };\n      testingTown.updatePlayerLocation(player, invalidLocation);\n      // Represents the conversation areas returned\n      const areas = testingTown.conversationAreas;\n      expect(areas.find(conv => conv.label === newLocation.conversationLabel)).toBe(\n        newConversationArea,\n      );\n      expect(areas.find(conv => conv.label === newSecondLocation.conversationLabel)).toBe(\n        prevConversationArea,\n      );\n      expect(areas.find(conv => conv.label === invalidLocation.conversationLabel)).toBeUndefined();\n\n      mockListeners.forEach(givenElement => {\n        expect(givenElement.onConversationAreaUpdated).toHaveBeenCalledTimes(0);\n      });\n    });\n\n    // Represents the case of checking conversation area being updated if the player stays in it\n    it('Represents the case of checking conversation area being updated if the player stays in it', async () => {\n      const newConversationArea = TestUtils.createConversationForTesting({\n        conversationLabel: 'newConversationArea1 Label',\n        conversationTopic: 'newConversationArea1 Topic',\n        boundingBox: { x: 10, y: 10, height: 5, width: 5 },\n      });\n      const prevConversationArea = TestUtils.createConversationForTesting({\n        conversationLabel: 'prev Label',\n        conversationTopic: 'prev Topic',\n        boundingBox: { x: 20, y: 20, height: 10, width: 10 },\n      });\n      const result = testingTown.addConversationArea(newConversationArea);\n      // Represents adding the previous active location from the conversation area of the player to the testing town to be tested\n      const resultPreviousLocation = testingTown.addConversationArea(prevConversationArea);\n      expect(result).toBe(true);\n      expect(resultPreviousLocation).toBe(true);\n\n      const player = new Player('Player 1');\n      const invalidPlayer = new Player('player 2');\n      invalidPlayer.location = {\n        moving: false,\n        rotation: 'front',\n        x: 25,\n        y: 25,\n        conversationLabel: 'abcdef',\n      };\n\n      await testingTown.addPlayer(player);\n      await testingTown.addPlayer(invalidPlayer);\n\n      const mockListener = mock<CoveyTownListener>();\n      // Represents the array of mock listeners\n      const mockListeners = [mock<CoveyTownListener>()];\n      mockListeners.forEach(element => {\n        testingTown.addTownListener(element);\n      });\n\n      testingTown.addTownListener(mockListener);\n      const newLocation: UserLocation = {\n        moving: false,\n        rotation: 'front',\n        x: 25,\n        y: 25,\n        conversationLabel: newConversationArea.label,\n      };\n\n      const myPlayerSession = new PlayerSession(player);\n      // const invalidPlayerSession = new PlayerSession(invalidPlayer);\n      // Represents the string representing the valid session token of the player\n      const playerToken = myPlayerSession.sessionToken;\n\n      expect(playerToken).toBeDefined();\n      testingTown.updatePlayerLocation(player, newLocation);\n      expect(player.activeConversationArea).toEqual(newConversationArea);\n      expect(mockListener.onConversationAreaUpdated).toHaveBeenCalledWith(newConversationArea);\n      expect(mockListener.onConversationAreaUpdated).toHaveBeenCalledTimes(1);\n      // Represents adding the invalid player into the conversation area in the case of which the onConversationUpdated will not be called\n      testingTown.updatePlayerLocation(invalidPlayer, newLocation);\n      expect(mockListener.onConversationAreaUpdated).toHaveBeenCalledWith(newConversationArea);\n      expect(mockListener.onConversationAreaUpdated).toHaveBeenCalledTimes(2);\n    });\n\n    // Represents the case of checking the player and the location states and making sure that they are valid\n    it('Represents the case of checking the player and the location states and making sure that they are valid', async () => {\n      const newConversationArea = TestUtils.createConversationForTesting({\n        conversationLabel: 'newConversationArea1 Label',\n        conversationTopic: 'newConversationArea1 Topic',\n        boundingBox: { x: 10, y: 10, height: 5, width: 5 },\n      });\n      const prevConversationArea = TestUtils.createConversationForTesting({\n        conversationLabel: 'prev Label',\n        conversationTopic: 'prev Topic',\n        boundingBox: { x: 20, y: 20, height: 10, width: 10 },\n      });\n      const result = testingTown.addConversationArea(newConversationArea);\n      // Represents adding the previous active location from the conversation area of the player to the testing town to be tested\n      const resultPreviousLocation = testingTown.addConversationArea(prevConversationArea);\n      expect(result).toBe(true);\n      expect(resultPreviousLocation).toBe(true);\n\n      const player = new Player('Player 1');\n      await testingTown.addPlayer(player);\n\n      const mockListener = mock<CoveyTownListener>();\n      // Represents the array of mock listeners\n      const mockListeners = [mock<CoveyTownListener>()];\n      mockListeners.forEach(element => {\n        testingTown.addTownListener(element);\n      });\n      testingTown.addTownListener(mockListener);\n      const newLocation: UserLocation = {\n        moving: false,\n        rotation: 'front',\n        x: 10,\n        y: 10,\n        conversationLabel: newConversationArea.label,\n      };\n      expect(mockListener.onPlayerJoined).toHaveBeenCalledTimes(0);\n      // Represents another location instance created\n      // const newSecondLocation: UserLocation = {\n      //   moving: false,\n      //   rotation: 'front',\n      //   x: 25,\n      //   y: 25,\n      //   conversationLabel: prevConversationArea.label,\n      // };\n      // Represents invalid location instance created\n      const invalidLocation: UserLocation = {\n        moving: false,\n        rotation: 'front',\n        x: 25,\n        y: 25,\n        conversationLabel: '',\n      };\n      // Represents player's states area before the location is updated\n      expect(player.activeConversationArea?.boundingBox).toBeUndefined();\n      expect(player.activeConversationArea?.label).toBeUndefined();\n      expect(player.activeConversationArea?.topic).toBeUndefined();\n      expect(player.activeConversationArea?.occupantsByID).toBeUndefined();\n      expect(player.id).toBeDefined();\n      expect(player.isWithin(newConversationArea)).toBeFalsy();\n      expect(player.userName).toEqual('Player 1');\n      expect(player.location).toBeDefined();\n      // Represents updating the player state location\n      testingTown.updatePlayerLocation(player, newLocation);\n      expect(player.activeConversationArea?.boundingBox).toEqual(newConversationArea.boundingBox);\n      expect(player.activeConversationArea?.label).toEqual(newConversationArea.label);\n      expect(player.activeConversationArea?.topic).toEqual(newConversationArea.topic);\n      expect(player.activeConversationArea?.occupantsByID).toEqual(\n        newConversationArea.occupantsByID,\n      );\n      expect(player.id).toBeDefined();\n      expect(player.isWithin(newConversationArea)).toBeTruthy();\n      expect(player.userName).toEqual('Player 1');\n      expect(player.location).toEqual(newLocation);\n      expect(mockListener.onConversationAreaUpdated).toHaveBeenCalledTimes(1);\n      expect(mockListener.onPlayerMoved).toHaveBeenCalledTimes(1);\n      expect(mockListener.onPlayerJoined).toHaveBeenCalledTimes(0);\n      expect(mockListener.onConversationAreaDestroyed).toHaveBeenCalledTimes(0);\n      // Represents updating the player state location\n      testingTown.updatePlayerLocation(player, invalidLocation);\n      expect(player.activeConversationArea?.boundingBox).toBeUndefined();\n      expect(player.activeConversationArea?.label).toBeUndefined();\n      expect(player.activeConversationArea?.topic).toBeUndefined();\n      expect(player.activeConversationArea?.occupantsByID).toBeUndefined();\n      expect(player.id).toBeDefined();\n      expect(player.isWithin(newConversationArea)).toBeFalsy();\n      expect(player.userName).toEqual('Player 1');\n      expect(player.location).toEqual(invalidLocation);\n      expect(mockListener.onConversationAreaUpdated).toHaveBeenCalledTimes(1);\n      expect(mockListener.onPlayerMoved).toHaveBeenCalledTimes(2);\n      expect(mockListener.onConversationAreaDestroyed).toHaveBeenCalledTimes(1);\n\n      // Represents the tests for the location state\n      expect(newLocation.conversationLabel).toEqual(newConversationArea.label);\n      expect(newLocation.moving).toBeFalsy();\n      expect(newLocation.rotation).toEqual('front');\n      expect(newLocation.x).toBeDefined();\n      expect(newLocation.y).toBeDefined();\n    });\n\n    // Represents the case of now checking when the player has been updated by location, if the removal and adding is valid to previous and new conversation areas respectively\n    it('Represents the case of now checking when the player has been updated by location, if the removal and adding is valid to previous and new conversation areas respectively', async () => {\n      const newConversationArea = TestUtils.createConversationForTesting({\n        conversationLabel: 'newConversationArea1 Label',\n        conversationTopic: 'newConversationArea1 Topic',\n        boundingBox: { x: 10, y: 10, height: 5, width: 5 },\n      });\n      const prevConversationArea = TestUtils.createConversationForTesting({\n        conversationLabel: 'prev Label',\n        conversationTopic: 'prev Topic',\n        boundingBox: { x: 20, y: 20, height: 10, width: 10 },\n      });\n      const result = testingTown.addConversationArea(newConversationArea);\n      // Represents adding the previous active location from the conversation area of the player to the testing town to be tested\n      const resultPreviousLocation = testingTown.addConversationArea(prevConversationArea);\n      expect(result).toBe(true);\n      expect(resultPreviousLocation).toBe(true);\n\n      const player = new Player('Player 1');\n      const secondPlayer = new Player('Player2');\n      await testingTown.addPlayer(player);\n      await testingTown.addPlayer(secondPlayer);\n\n      const mockListener = mock<CoveyTownListener>();\n      // Represents the array of mock listeners\n      const mockListeners = [mock<CoveyTownListener>()];\n      mockListeners.forEach(element => {\n        testingTown.addTownListener(element);\n      });\n      testingTown.addTownListener(mockListener);\n      const newLocation: UserLocation = {\n        moving: false,\n        rotation: 'front',\n        x: 10,\n        y: 10,\n        conversationLabel: newConversationArea.label,\n      };\n      expect(mockListener.onPlayerJoined).toHaveBeenCalledTimes(0);\n      // Represents another location instance created\n      const newSecondLocation: UserLocation = {\n        moving: false,\n        rotation: 'front',\n        x: 25,\n        y: 25,\n        conversationLabel: prevConversationArea.label,\n      };\n\n      const areas = testingTown.conversationAreas;\n\n      expect(player.activeConversationArea).toBeUndefined();\n      expect(player.location.conversationLabel).toBeUndefined();\n      expect(player.activeConversationArea?.occupantsByID.length).toBeUndefined();\n      // Represents updating the location of the player\n      testingTown.updatePlayerLocation(player, newLocation);\n      expect(player.activeConversationArea).toEqual(newConversationArea);\n      expect(player.location.conversationLabel).toEqual(newConversationArea.label);\n      expect(player.activeConversationArea?.occupantsByID.length).toEqual(1);\n      expect(mockListener.onConversationAreaUpdated).toHaveBeenCalledTimes(1);\n      expect(mockListener.onPlayerMoved).toHaveBeenCalledTimes(1);\n      expect(mockListener.onPlayerJoined).toHaveBeenCalledTimes(0);\n\n      // Represents moving this player from one conversation area to another conversation area\n      expect(areas.length).toEqual(2);\n      expect(areas[0]).toEqual(newConversationArea);\n      expect(areas[1]).toEqual(prevConversationArea);\n      expect(prevConversationArea.occupantsByID.length).toEqual(0);\n      expect(prevConversationArea).not.toEqual(newConversationArea);\n      expect(prevConversationArea).toBeDefined();\n\n      testingTown.updatePlayerLocation(player, newSecondLocation);\n      // Checking if onConversationAreaDestroy is called\n      expect(newConversationArea.occupantsByID.length).toBe(0);\n      expect(mockListener.onConversationAreaDestroyed).toHaveBeenCalledTimes(1);\n      mockListeners.forEach(givenElement => {\n        expect(givenElement.onConversationAreaDestroyed).toHaveBeenCalledWith(newConversationArea);\n      });\n      expect(areas.length).toEqual(1);\n      expect(areas[0]).toEqual(prevConversationArea);\n      expect(areas[1]).toBeUndefined();\n      expect(mockListener.onPlayerMoved).toHaveBeenCalledTimes(2);\n      expect(mockListener.onConversationAreaUpdated).toHaveBeenCalledTimes(2);\n      expect(prevConversationArea.occupantsByID.length).toEqual(1);\n      expect(player.activeConversationArea).toEqual(prevConversationArea);\n      expect(player.activeConversationArea?.label).toEqual(prevConversationArea.label);\n      expect(player.activeConversationArea?.topic).toEqual(prevConversationArea.topic);\n      expect(player.activeConversationArea?.boundingBox).toEqual(prevConversationArea.boundingBox);\n      mockListeners.forEach(givenElement => {\n        expect(givenElement.onConversationAreaUpdated).toHaveBeenCalledWith(prevConversationArea);\n      });\n      mockListeners.forEach(givenElement => {\n        expect(givenElement.onPlayerMoved).toHaveBeenCalledWith(player);\n      });\n      mockListeners.forEach(givenElement => {\n        expect(givenElement.onPlayerJoined).not.toHaveBeenCalledWith(player);\n      });\n\n      // Represents the test of adding having two players in a conversation area and when one is removed, just\n      // call onConversationAreaUpdated and not onConversationAreaDestroyed\n      testingTown.updatePlayerLocation(secondPlayer, newSecondLocation);\n      expect(prevConversationArea.occupantsByID.length).toEqual(2);\n      expect(prevConversationArea.label).toEqual(secondPlayer.activeConversationArea?.label);\n      expect(prevConversationArea.topic).toEqual(secondPlayer.activeConversationArea?.topic);\n      expect(prevConversationArea.boundingBox).toEqual(\n        secondPlayer.activeConversationArea?.boundingBox,\n      );\n      // Represents moving the player back to newConversationArea\n      testingTown.updatePlayerLocation(player, newLocation);\n      mockListeners.forEach(givenElement => {\n        expect(givenElement.onPlayerMoved).toHaveBeenCalledWith(secondPlayer);\n      });\n      expect(prevConversationArea.occupantsByID.length).toEqual(1);\n      expect(mockListener.onConversationAreaUpdated).toHaveBeenCalledTimes(4);\n      mockListeners.forEach(givenElement => {\n        expect(givenElement.onConversationAreaUpdated).toHaveBeenCalledWith(prevConversationArea);\n      });\n      mockListeners.forEach(givenElement => {\n        expect(givenElement.onPlayerMoved).toHaveBeenCalledWith(player);\n      });\n      expect(player.location).toEqual(newLocation);\n      // Represents the case that since the newConversationArea is destroyed, its active conversation area will be undefined\n      expect(player.activeConversationArea).toBeUndefined();\n    });\n\n    // Represents the case of checking whether the town listener is called when it is destroyed or added\n    it('Represents the case of checking whether the town listener is called when it is destroyed or added', async () => {\n      const newConversationArea = TestUtils.createConversationForTesting({\n        conversationLabel: 'newConversationArea1 Label',\n        conversationTopic: 'newConversationArea1 Topic',\n        boundingBox: { x: 10, y: 10, height: 5, width: 5 },\n      });\n      const prevConversationArea = TestUtils.createConversationForTesting({\n        conversationLabel: 'prev Label',\n        conversationTopic: 'prev Topic',\n        boundingBox: { x: 20, y: 20, height: 10, width: 10 },\n      });\n      const result = testingTown.addConversationArea(newConversationArea);\n      // Represents adding the previous active location from the conversation area of the player to the testing town to be tested\n      const resultPreviousLocation = testingTown.addConversationArea(prevConversationArea);\n      expect(result).toBe(true);\n      expect(resultPreviousLocation).toBe(true);\n\n      const player = new Player('Player 1');\n      const playerCheckEdgeCase = new Player('player');\n\n      const mockListener = mock<CoveyTownListener>();\n      // Represents the array of mock listeners\n      const mockListeners = [mock<CoveyTownListener>()];\n      mockListeners.forEach(element => {\n        testingTown.addTownListener(element);\n      });\n      // mockListeners.push(mockListener);\n      testingTown.addTownListener(mockListener);\n      const newLocation: UserLocation = {\n        moving: false,\n        rotation: 'front',\n        x: 25,\n        y: 25,\n        conversationLabel: newConversationArea.label,\n      };\n      // Represents another location instance created\n      const newSecondLocation: UserLocation = {\n        moving: false,\n        rotation: 'front',\n        x: 25,\n        y: 25,\n        conversationLabel: prevConversationArea.label,\n      };\n      // Represents invalid location instance created\n      const invalidLocation: UserLocation = {\n        moving: false,\n        rotation: 'front',\n        x: 25,\n        y: 25,\n        conversationLabel: '',\n      };\n\n      // Represents invalid location instance created\n      const invalidConversationLocation: UserLocation = {\n        moving: false,\n        rotation: 'front',\n        x: 25,\n        y: 25,\n        conversationLabel: 'abc',\n      };\n      // Represents the case of when a player moves from an conversation area into an invalid conversation area\n      testingTown.updatePlayerLocation(playerCheckEdgeCase, newLocation);\n      expect(playerCheckEdgeCase.activeConversationArea).toEqual(newConversationArea);\n      expect(playerCheckEdgeCase.activeConversationArea?.occupantsByID.length).toEqual(\n        newConversationArea.occupantsByID.length,\n      );\n      testingTown.updatePlayerLocation(playerCheckEdgeCase, invalidConversationLocation);\n      expect(playerCheckEdgeCase.activeConversationArea).toBeUndefined();\n      expect(playerCheckEdgeCase.activeConversationArea?.occupantsByID.length).toBeUndefined();\n      expect(mockListener.onConversationAreaDestroyed).toHaveBeenCalledWith(newConversationArea);\n\n      testingTown.updatePlayerLocation(player, invalidLocation);\n      // Represents the onPlayer being moved\n      expect(mockListener.onPlayerMoved).toHaveBeenCalledTimes(3);\n      // Represents removing a town listener and then updating the player again, in the case of which it should not have been called\n      testingTown.removeTownListener(mockListener);\n      testingTown.updatePlayerLocation(player, newLocation);\n      expect(mockListener.onPlayerMoved).toHaveBeenCalledTimes(3);\n      expect(mockListener.onConversationAreaUpdated).toHaveBeenCalledTimes(1);\n      // Represents adding the listener again\n      testingTown.addTownListener(mockListener);\n      testingTown.updatePlayerLocation(player, newSecondLocation);\n      expect(mockListener.onPlayerMoved).toHaveBeenCalledTimes(4);\n      expect(mockListener.onConversationAreaUpdated).toHaveBeenCalledTimes(2);\n      expect(mockListener.onConversationAreaDestroyed).toHaveBeenCalledTimes(1);\n      testingTown.removePlayerFromConversationArea(player, prevConversationArea);\n      expect(mockListener.onPlayerDisconnected).toHaveBeenCalledTimes(0);\n      expect(mockListener.onTownDestroyed).toHaveBeenCalledTimes(0);\n    });\n\n    // Represents the case of when the player being removed from its active existing conversation area is checked when its location is updated since it moves to a new conversation area or out of the exisitng previous active conversation area\n    it('Should remove the player from its existing or active conversation area when the location is updated since the player moves into a new conversation area', async () => {\n      const newConversationArea = TestUtils.createConversationForTesting({\n        conversationLabel: 'newConversationArea1 Label',\n        conversationTopic: 'newConversationArea1 Topic',\n        boundingBox: { x: 10, y: 10, height: 5, width: 5 },\n      });\n      const prevConversationArea = TestUtils.createConversationForTesting({\n        conversationLabel: 'prev Label',\n        conversationTopic: 'prev Topic',\n        boundingBox: { x: 20, y: 20, height: 10, width: 10 },\n      });\n\n      const result = testingTown.addConversationArea(newConversationArea);\n      // Represents adding the previous active location from the conversation area of the player to the testing town to be tested\n      const resultPreviousLocation = testingTown.addConversationArea(prevConversationArea);\n      expect(result).toBe(true);\n      expect(resultPreviousLocation).toBe(true);\n\n      const mockListener = mock<CoveyTownListener>();\n      // Represents the array of mock listeners\n      const mockListeners = [mock<CoveyTownListener>()];\n      mockListeners.forEach(element => {\n        testingTown.addTownListener(element);\n      });\n      testingTown.addTownListener(mockListener);\n\n      const player = new Player('Player1');\n\n      const secondPlayer = new Player('Player2');\n\n      const thirdPlayer = new Player('Player3');\n\n      // player.activeConversationArea = prevConversationArea;\n      // Represents adding the player into the prevConversationArea to check for the updatePlayerLocation function\n      await testingTown.addPlayer(player);\n      await testingTown.addPlayer(secondPlayer);\n      await testingTown.addPlayer(thirdPlayer);\n      // Represents the case of when a player joins a town\n      expect(mockListener.onPlayerJoined).toHaveBeenCalledTimes(3);\n\n      // Represents the cases to check whether the conversation areas and the players are valid\n      expect(typeof player.id).toBe('string');\n      expect(typeof secondPlayer.id).toBe('string');\n      expect(typeof thirdPlayer.id).toBe('string');\n      expect(typeof newConversationArea.topic && typeof newConversationArea.label).toBe('string');\n      expect(typeof prevConversationArea.topic && typeof prevConversationArea.label).toBe('string');\n\n      const newLocation: UserLocation = {\n        moving: false,\n        rotation: 'front',\n        x: 25,\n        y: 25,\n        conversationLabel: newConversationArea.label,\n      };\n\n      // Represents another location instance created\n      const newSecondLocation: UserLocation = {\n        moving: false,\n        rotation: 'front',\n        x: 25,\n        y: 25,\n        conversationLabel: prevConversationArea.label,\n      };\n\n      // Represents testing when a player is moved into a conversation area from not a previous conversation area\n      testingTown.updatePlayerLocation(thirdPlayer, newSecondLocation);\n      expect(mockListener.onConversationAreaDestroyed).toHaveBeenCalledTimes(0);\n      expect(mockListener.onConversationAreaUpdated).toHaveBeenCalledTimes(1);\n\n      // Represents that the label, topic, bounding box, will be undefined before the player is updated into the location of the\n      // conversation area\n      expect(player.activeConversationArea?.label).toBeUndefined();\n      expect(player.activeConversationArea?.topic).toBeUndefined();\n      expect(player.activeConversationArea?.boundingBox).toBeUndefined();\n      // Represents no players that have been added\n      expect(newConversationArea.occupantsByID.length).toBe(0);\n      // Represents the testing of bounding boxes\n      expect(player.location.x).not.toEqual(newLocation.y);\n      expect(player.location.y).not.toEqual(newLocation.y);\n      // Now we know that the player is to be moved into a conversation area\n      testingTown.updatePlayerLocation(player, newLocation);\n\n      // Represents the testing of bounding boxes\n      expect(player.location.x).toEqual(newLocation.x);\n      expect(player.location.y).toEqual(newLocation.y);\n      // Represents a player that has been added by updating its location\n      expect(newConversationArea.occupantsByID.length).toEqual(1);\n\n      // Represents the test when a player is tried to be updated in the same conversation area in the case of which,\n      // the listener will not be updated\n      testingTown.updatePlayerLocation(player, newLocation);\n      expect(mockListener.onConversationAreaUpdated).toHaveBeenCalledTimes(2);\n      expect(mockListener.onPlayerMoved).toHaveBeenCalledTimes(3);\n      expect(mockListener.onConversationAreaDestroyed).toHaveBeenCalledTimes(0); //\n\n      // Represents the player being moved\n      expect(player.activeConversationArea?.label).toEqual(newConversationArea.label);\n      expect(player.activeConversationArea?.topic).toEqual(newConversationArea.topic);\n      expect(player.activeConversationArea?.boundingBox).toEqual(newConversationArea.boundingBox);\n\n      // Represents no players that are present in the prevConversationArea\n      expect(prevConversationArea.occupantsByID.length).toEqual(1);\n      // Represents that the label, topic, bounding box, will be undefined before the secondPlayer is updated into the location of the\n      // conversation area\n      expect(secondPlayer.activeConversationArea?.label).toBeUndefined();\n      expect(secondPlayer.activeConversationArea?.topic).toBeUndefined();\n      expect(secondPlayer.activeConversationArea?.boundingBox).toBeUndefined();\n\n      // Represents the testing of bounding boxes\n      expect(secondPlayer.location.x).not.toEqual(newSecondLocation.x);\n      expect(secondPlayer.location.y).not.toEqual(newSecondLocation.y);\n\n      // Now we know that the player is to be moved into a conversation area\n      testingTown.updatePlayerLocation(secondPlayer, newSecondLocation);\n\n      // Represents the testing of bounding boxes\n      expect(secondPlayer.location.x).toEqual(newSecondLocation.y);\n      expect(secondPlayer.location.y).toEqual(newSecondLocation.y);\n\n      // Represents a player that has been added by updating its location\n      expect(prevConversationArea.occupantsByID.length).toEqual(2);\n      // Represents the secondPlayer being moved\n      expect(secondPlayer.activeConversationArea?.label).toEqual(prevConversationArea.label);\n      expect(secondPlayer.activeConversationArea?.topic).toEqual(prevConversationArea.topic);\n      expect(secondPlayer.activeConversationArea?.boundingBox).toEqual(\n        prevConversationArea.boundingBox,\n      );\n      // Represents the onPlsayerDisconnected test case that in the case of which the the number of times it is called should be 1\n      expect(mockListener.onPlayerMoved).toHaveBeenCalledTimes(4);\n      // Represents the test of when the listeners are called every time a player is moved\n      mockListeners.forEach(element => {\n        expect(element.onPlayerMoved).toHaveBeenCalledWith(player);\n      });\n      mockListeners.forEach(givenElement => {\n        expect(givenElement.onPlayerMoved).toHaveBeenCalledWith(secondPlayer);\n      });\n\n      // Represents checking if the conversation areas are different, so that the location can be updated\n      expect(secondPlayer.activeConversationArea).not.toBe(newConversationArea);\n      // Now that the second player is in the prevConversation area, we can update and make it to move into the\n      // new conversation area and remove it from the prevConverationArea\n      testingTown.updatePlayerLocation(secondPlayer, newLocation);\n      // To check whether the second player has been moved or not\n      mockListeners.forEach(givenElement => {\n        expect(givenElement.onPlayerMoved).toHaveBeenCalledWith(secondPlayer);\n      });\n      expect(mockListener.onPlayerMoved).toHaveBeenCalledTimes(5);\n\n      // Represents showing the test of when the previous conversation has the player removed\n      expect(prevConversationArea.occupantsByID.length).toEqual(1);\n      // Represents the test when an onconversationarea updated and destroyed are called when the secondPlayer has the location updated\n      mockListeners.forEach(givenElement => {\n        expect(givenElement.onConversationAreaUpdated).toHaveBeenCalledWith(newConversationArea);\n      });\n      mockListeners.forEach(givenElement => {\n        expect(givenElement.onConversationAreaDestroyed).not.toHaveBeenCalledWith(\n          prevConversationArea,\n        );\n      });\n      // Represents the onConversationAreaDestroyed being called once since the prevConversation area is to be destroyed\n      expect(mockListener.onConversationAreaDestroyed).toHaveBeenCalledTimes(0);\n      // Represents the onConversationAreaUpdated being called 3 times\n      expect(mockListener.onConversationAreaUpdated).toHaveBeenCalledTimes(5);\n      // Represents the test to check whether the secondPlayer has moved to the newConversationArea succesfully\n      expect(newConversationArea.occupantsByID.length).toEqual(2); // Since it has two players now\n      expect(newConversationArea.occupantsByID[0]).toEqual(player.id);\n      expect(newConversationArea.occupantsByID[1]).toEqual(secondPlayer.id);\n    });\n  });\n\n  // Represents testing the CoveyTownController.destroySession function that states that when a player is destroyed, they should be removed from\n  // the coversation area\n  describe('destroySession', () => {\n    let testingTown: CoveyTownController;\n    beforeEach(() => {\n      const townName = `destroySession test town ${nanoid()}`;\n      testingTown = new CoveyTownController(townName, false);\n    });\n    it('Tests for when a players session is destroyed, they should be removed from the conversation area', async () => {\n      const newConversationArea = TestUtils.createConversationForTesting({\n        boundingBox: { x: 10, y: 10, height: 5, width: 5 },\n      });\n      const result = testingTown.addConversationArea(newConversationArea);\n      expect(result).toBe(true);\n      const newLocation: UserLocation = {\n        moving: false,\n        rotation: 'front',\n        x: 25,\n        y: 25,\n        conversationLabel: newConversationArea.label,\n      };\n      // Represents the first player in the conversation area\n      const playerAtInstance = new Player(nanoid());\n      // Represents the second player in the conversation area\n      const secondPlayerAtInstance = new Player(nanoid());\n      // Represents the session of the given PlayerAtInstance\n      const playerSession = new PlayerSession(playerAtInstance);\n      // Represents adding the first and the second players in the conversation area in the testing town\n      await testingTown.addPlayer(playerAtInstance);\n      await testingTown.addPlayer(secondPlayerAtInstance);\n\n      // Represents updating the location of the playerAtInstance in the newLocation for both of the players to be in the saem location to test\n      // the detroySession\n      testingTown.updatePlayerLocation(playerAtInstance, newLocation);\n      // Represents updating the location of the secondPlayerAtInstance for it to be in the newLocation along with the playerAtInstance\n      testingTown.updatePlayerLocation(secondPlayerAtInstance, newLocation);\n\n      // Represents the test that represents both the players present in the testing down before destroying one of the sessions\n      expect(testingTown.players.length).toBe(2);\n\n      // Represents the test that represents that the occupant ID list size is 2 before a player session is destroyed\n      const areas = testingTown.conversationAreas;\n\n      // Represents the test case of when there are two occupant IDs in the areas before one player is destroyed\n      expect(testingTown.players.length).toBe(2);\n\n      expect(areas[0].occupantsByID.length).toBe(2);\n\n      // Represents destroying the player session in the case of which, the player will have to be removed from the given conversation\n      // area is its session is destroyed\n      testingTown.destroySession(playerSession);\n      // Represents the player being removed from the conversation area after the player session is destroyed\n      expect(testingTown.players.length).toBe(1);\n\n      // Represents the test case of when there is just one occupantByID left in the areas because the other playerAtInstance's session has been destroyed\n      expect(areas.filter(element => element.occupantsByID).length).toBe(1);\n      // Represents the area to have one occupant ID removed after destroying a player's session\n      expect(areas[0].occupantsByID.length).toBe(1);\n    });\n    it('should emit an onPlayerDisconnected event when a player is disconnected/destroyed or removed from its given conversation area', async () => {\n      // Represents creating a new conversation area for testing purposes\n      const newConversationArea = TestUtils.createConversationForTesting({\n        boundingBox: { x: 10, y: 10, height: 5, width: 5 },\n      });\n      // Represents adding a newConversationArea to test for the destroySession method\n      const result = testingTown.addConversationArea(newConversationArea);\n      // Represents the test base case of when a conversation area exists, return true\n      expect(result).toBe(true);\n\n      const mockListener = mock<CoveyTownListener>();\n      // Represents the array of mock listeners\n      const mockListeners = [mock<CoveyTownListener>()];\n      mockListeners.forEach(element => {\n        testingTown.addTownListener(element);\n      });\n\n      // Represents adding the MockListener to the testingTown\n      testingTown.addTownListener(mockListener);\n\n      const playerAtInstance = new Player(nanoid());\n      // Represents the session of the given PlayerAtInstance\n      const playerSession = new PlayerSession(playerAtInstance);\n      await testingTown.addPlayer(playerAtInstance);\n\n      // Represents case of when the player session has been destroyed\n      testingTown.destroySession(playerSession);\n      // Represents the onPlayerDisconnected test case that in the case of which the the number of times it is called should be 1\n      expect(mockListener.onPlayerDisconnected).toHaveBeenCalledTimes(1);\n      // Represents the test of when the listeners are called every time a player is destroyed\n      mockListeners.forEach(element => {\n        expect(element.onPlayerDisconnected).toHaveBeenCalledWith(playerAtInstance);\n      });\n    });\n  });\n});\n"},"/Users/madhur/Downloads/hw3-handout final/src/client/CoveyTownConversationAPI.test.ts":{"tests":[{"id":"40","name":"Create Conversation Area API Executes without error when creating a new conversation","location":{"start":{"column":3,"line":89}}},{"id":"41","name":"Create Conversation Area API Executes with error when creating a new conversation","location":{"start":{"column":3,"line":111}}},{"id":"42","name":"Create Conversation Area API Executes with error when creating a new conversation due to invalid session and town","location":{"start":{"column":3,"line":143}}},{"id":"43","name":"conversationAreaCreateHandler Checks for a invalid session token before creating a conversation area","location":{"start":{"column":3,"line":186}}},{"id":"44","name":"conversationAreaCreateHandler Checks for a valid conversation area before creating a conversation area actually","location":{"start":{"column":3,"line":226}}},{"id":"45","name":"conversationAreaCreateHandler Checks for an invalid conversation area to be added, in the case of which, an error is supposed to be thrown","location":{"start":{"column":3,"line":285}}}],"source":"import CORS from 'cors';\n\nimport Express from 'express';\n\nimport http from 'http';\n\nimport { nanoid } from 'nanoid';\n\nimport { AddressInfo } from 'net';\n\nimport { mock, mockReset } from 'jest-mock-extended';\n\nimport CoveyTownController from '../lib/CoveyTownController';\n\nimport CoveyTownsStore from '../lib/CoveyTownsStore';\n\nimport addTownRoutes from '../router/towns';\n\nimport * as requestHandlers from '../requestHandlers/CoveyTownRequestHandlers';\n\nimport { createConversationForTesting } from './TestUtils';\n\nimport TownsServiceClient, { ServerConversationArea } from './TownsServiceClient';\nimport PlayerSession from '../types/PlayerSession';\nimport Player from '../types/Player';\n\ntype TestTownData = {\n  friendlyName: string;\n\n  coveyTownID: string;\n\n  isPubliclyListed: boolean;\n\n  townUpdatePassword: string;\n};\n\ndescribe('Create Conversation Area API', () => {\n  let server: http.Server;\n\n  let apiClient: TownsServiceClient;\n\n  async function createTownForTesting(\n    friendlyNameToUse?: string,\n\n    isPublic = false,\n  ): Promise<TestTownData> {\n    const friendlyName =\n      friendlyNameToUse !== undefined\n        ? friendlyNameToUse\n        : `${isPublic ? 'Public' : 'Private'}TestingTown=${nanoid()}`;\n\n    const ret = await apiClient.createTown({\n      friendlyName,\n\n      isPubliclyListed: isPublic,\n    });\n\n    return {\n      friendlyName,\n\n      isPubliclyListed: isPublic,\n\n      coveyTownID: ret.coveyTownID,\n\n      townUpdatePassword: ret.coveyTownPassword,\n    };\n  }\n\n  beforeAll(async () => {\n    const app = Express();\n\n    app.use(CORS());\n\n    server = http.createServer(app);\n\n    addTownRoutes(server, app);\n\n    await server.listen();\n\n    const address = server.address() as AddressInfo;\n\n    apiClient = new TownsServiceClient(`http://127.0.0.1:${address.port}`);\n  });\n\n  afterAll(async () => {\n    await server.close();\n  });\n\n  it('Executes without error when creating a new conversation', async () => {\n    const testingTown = await createTownForTesting(undefined, true);\n\n    const testingSession = await apiClient.joinTown({\n      userName: nanoid(),\n\n      coveyTownID: testingTown.coveyTownID,\n    });\n\n    await apiClient.createConversationArea({\n      conversationArea: createConversationForTesting(),\n\n      coveyTownID: testingTown.coveyTownID,\n\n      sessionToken: testingSession.coveySessionToken,\n    });\n  });\n\n  // Represents the tests for the POST api in town.ts in order to catch errors based on when teh createConversationAreaHandler is\n\n  // called\n\n  it('Executes with error when creating a new conversation', async () => {\n    const testingTown = await createTownForTesting(undefined, true);\n\n    const testingSession = await apiClient.joinTown({\n      userName: nanoid(),\n\n      coveyTownID: testingTown.coveyTownID,\n    });\n\n    const convAreaTesting = createConversationForTesting();\n\n    jest.spyOn(requestHandlers, 'conversationAreaCreateHandler').mockImplementationOnce(() => {\n      throw new Error('Error thrown in the case of this creation of conversation create handler');\n    });\n\n    try {\n      await apiClient.createConversationArea({\n        conversationArea: convAreaTesting,\n\n        coveyTownID: testingTown.coveyTownID,\n\n        sessionToken: testingSession.coveySessionToken,\n      });\n    } catch (error) {\n      const responseMessage = 'Request failed with status code 500';\n\n      expect(error).toEqual(new Error(responseMessage));\n    }\n  });\n\n  // Represents the case of when the conversation area is valid and not undefined and when the testing session or testing town is invalid, in the case of which, catch an error\n\n  it('Executes with error when creating a new conversation due to invalid session and town', async () => {\n    const testingTown = await createTownForTesting('givenTown', true);\n\n    const testingSession = await apiClient.joinTown({\n      userName: nanoid(),\n\n      coveyTownID: testingTown.coveyTownID,\n    });\n\n    try {\n      await apiClient.createConversationArea({\n        conversationArea: createConversationForTesting(),\n\n        coveyTownID: testingTown.coveyTownID,\n        sessionToken: testingSession.coveySessionToken,\n      });\n    } catch (error) {\n      expect(error).toEqual('Internal server error, please see log in server for more details');\n    }\n  });\n});\n\ndescribe('conversationAreaCreateHandler', () => {\n  const mockCoveyTownStore = mock<CoveyTownsStore>();\n\n  const mockCoveyTownController = mock<CoveyTownController>();\n\n  beforeAll(() => {\n    // Set up a spy for CoveyTownsStore that will always return our mockCoveyTownsStore as the singleton instance\n\n    jest.spyOn(CoveyTownsStore, 'getInstance').mockReturnValue(mockCoveyTownStore);\n  });\n\n  beforeEach(() => {\n    // Reset all mock calls, and ensure that getControllerForTown will always return the same mock controller\n\n    mockReset(mockCoveyTownController);\n\n    mockReset(mockCoveyTownStore);\n\n    mockCoveyTownStore.getControllerForTown.mockReturnValue(mockCoveyTownController);\n  });\n\n  it('Checks for a invalid session token before creating a conversation area', () => {\n    const coveyTownID = nanoid();\n\n    const conversationArea: ServerConversationArea = {\n      boundingBox: { height: 1, width: 1, x: 1, y: 1 },\n\n      label: nanoid(),\n\n      occupantsByID: [],\n\n      topic: nanoid(),\n    };\n\n    const invalidSessionToken = nanoid();\n\n    // Make sure to return 'undefined' regardless of what session token is passed\n\n    mockCoveyTownController.getSessionByToken.mockReturnValueOnce(undefined);\n    // jest.spyOn(requestHandlers, 'conversationAreaCreateHandler').mockImplementationOnce(() => {\n    //   throw new Error('Error thrown in the case of this creation of invalid session');\n    // });\n\n    const action = requestHandlers.conversationAreaCreateHandler({\n      conversationArea,\n\n      coveyTownID,\n\n      sessionToken: invalidSessionToken,\n    });\n\n    const response = {\n      isOK: false,\n      response: {},\n      message: `Unable to create conversation area ${conversationArea.label} with topic ${conversationArea.topic}`,\n    };\n\n    expect(action).toEqual(response);\n    expect(mockCoveyTownController.addConversationArea).not.toHaveBeenCalled();\n  });\n\n  it('Checks for a valid conversation area before creating a conversation area actually', () => {\n    const coveyTownID = nanoid();\n    const mockSession = new PlayerSession(new Player(nanoid()));\n\n    const conversationArea = {\n      label: 'newConversationArea1 Label',\n      topic: 'newConversationArea1 Topic',\n      occupantsByID: [],\n      boundingBox: { x: 10, y: 10, height: 5, width: 5 },\n    };\n\n    // const validSessionToken =\n    //   mockCoveyTownController.getSessionByToken.mockReturnValue(mockSession);\n\n    // Make sure to return 'undefined' regardless of what session token is passed\n\n    const addSession = mockCoveyTownController.getSessionByToken.mockReturnValueOnce(mockSession);\n    expect(addSession).toBeTruthy();\n\n    const action = requestHandlers.conversationAreaCreateHandler({\n      conversationArea,\n\n      coveyTownID,\n\n      sessionToken: mockSession.sessionToken,\n    });\n\n    const success = mockCoveyTownController.addConversationArea(conversationArea);\n\n    const responseToConversationArea = {\n      isOK: success,\n      response: {},\n      message: !success\n        ? `Unable to create conversation area ${conversationArea.label} with topic ${conversationArea.topic}`\n        : undefined,\n    };\n\n    const responseToConversationArea1 = {\n      isOK: success,\n      response: {},\n      message: success\n        ? `Unable to create conversation area ${conversationArea.label} with topic ${conversationArea.topic}`\n        : undefined,\n    };\n\n    const responseToConversationArea2 = {\n      isOK: success,\n      response: {},\n      message: !success ? '' : undefined,\n    };\n\n    expect(action).toEqual(responseToConversationArea);\n    expect(action).not.toEqual(responseToConversationArea1);\n    expect(action).not.toEqual(responseToConversationArea2);\n    expect(mockCoveyTownController.addConversationArea).toHaveBeenCalledTimes(2);\n    expect(mockCoveyTownController.addConversationArea).toHaveBeenCalledWith(conversationArea);\n  });\n\n  // Represents the case of checking when the conversation area is invalid in the case of which, an error should be thrown\n  it('Checks for an invalid conversation area to be added, in the case of which, an error is supposed to be thrown', () => {\n    const coveyTownID = nanoid();\n    const mockSession = new PlayerSession(new Player(nanoid()));\n\n    const conversationArea: ServerConversationArea = {\n      boundingBox: { height: 0, width: 0, x: 1, y: 1 },\n\n      label: nanoid(),\n\n      occupantsByID: [],\n\n      topic: '',\n    };\n\n    // const validSessionToken =\n    //   mockCoveyTownController.getSessionByToken.mockReturnValue(mockSession);\n\n    // Make sure to return 'undefined' regardless of what session token is passed\n\n    // const addSession = mockCoveyTownController.getSessionByToken.mockReturnValueOnce(mockSession);\n\n    mockCoveyTownController.addConversationArea.mockReturnValueOnce(false);\n    const action = requestHandlers.conversationAreaCreateHandler({\n      conversationArea,\n\n      coveyTownID,\n\n      sessionToken: mockSession.sessionToken,\n    });\n\n    // const failure = mockCoveyTownController.addConversationArea(conversationArea);\n\n    const responseToConversationArea = {\n      isOK: false,\n      response: {},\n      message: `Unable to create conversation area ${conversationArea.label} with topic ${conversationArea.topic}`,\n    };\n\n    expect(action).toEqual(responseToConversationArea);\n    expect(mockCoveyTownController.addConversationArea).toHaveBeenCalledTimes(0);\n    expect(mockCoveyTownController.addConversationArea).not.toHaveBeenCalledWith(conversationArea);\n  });\n});\n"}},"projectRoot":"/Users/madhur/Downloads/hw3-handout final","config":{"$schema":"./node_modules/@stryker-mutator/core/schema/stryker-schema.json","_comment":"This config was generated using 'stryker init'. Please take a look at: https://stryker-mutator.io/docs/stryker-js/configuration/ for more information","packageManager":"npm","reporters":["html","clear-text","json","progress"],"tempDirName":".strykerTmp","checkers":["typescript"],"tsconfigFile":"tsconfig.json","testRunner":"jest","coverageAnalysis":"perTest","timeoutFactor":5,"timeoutMS":15000,"mutate":["src/lib/CoveyTownController.ts:123-126","src/lib/CoveyTownController.ts:140-156","src/lib/CoveyTownController.ts:168-175","src/lib/CoveyTownController.ts:191-210","src/lib/CoveyTownController.ts:219-225","src/types/Player.ts:56-65","src/requestHandlers/CoveyTownRequestHandlers.ts:184-199","src/router/towns.ts:112-127"],"allowConsoleColors":true,"checkerNodeArgs":[],"maxTestRunnerReuse":0,"commandRunner":{"command":"npm test"},"clearTextReporter":{"allowColor":true,"logTests":true,"maxTestsToLog":3},"dashboard":{"baseUrl":"https://dashboard.stryker-mutator.io/api/reports","reportType":"full"},"eventReporter":{"baseDir":"reports/mutation/events"},"ignorePatterns":[],"fileLogLevel":"off","inPlace":false,"logLevel":"info","maxConcurrentTestRunners":9007199254740991,"mutator":{"plugins":null,"excludedMutations":[]},"plugins":["@stryker-mutator/*","/Users/madhur/Downloads/hw3-handout final/node_modules/@stryker-mutator/core/dist/src/reporters/index.js"],"appendPlugins":[],"jsonReporter":{"fileName":"reports/mutation/mutation.json"},"disableTypeChecks":"{test,src,lib}/**/*.{js,ts,jsx,tsx,html,vue}","symlinkNodeModules":true,"cleanTempDir":true,"testRunnerNodeArgs":[],"thresholds":{"high":80,"low":60,"break":null},"dryRunTimeoutMinutes":5,"warnings":true,"disableBail":false,"configFile":"/Users/madhur/Downloads/hw3-handout final/stryker.conf.json","jest":{"projectType":"custom","enableFindRelatedTests":true}},"framework":{"name":"StrykerJS","version":"5.6.1","branding":{"homepageUrl":"https://stryker-mutator.io","imageUrl":"data:image/svg+xml;utf8,%3Csvg viewBox='0 0 1458 1458' xmlns='http://www.w3.org/2000/svg' fill-rule='evenodd' clip-rule='evenodd' stroke-linejoin='round' stroke-miterlimit='2'%3E%3Cpath fill='none' d='M0 0h1458v1458H0z'/%3E%3CclipPath id='a'%3E%3Cpath d='M0 0h1458v1458H0z'/%3E%3C/clipPath%3E%3Cg clip-path='url(%23a)'%3E%3Cpath d='M1458 729c0 402.655-326.345 729-729 729S0 1131.655 0 729C0 326.445 326.345 0 729 0s729 326.345 729 729' fill='%23e74c3c' fill-rule='nonzero'/%3E%3Cpath d='M778.349 1456.15L576.6 1254.401l233-105 85-78.668v-64.332l-257-257-44-187-50-208 251.806-82.793L1076.6 389.401l380.14 379.15c-19.681 367.728-311.914 663.049-678.391 687.599z' fill-opacity='.3'/%3E%3Cpath d='M753.4 329.503c41.79 0 74.579 7.83 97.925 25.444 23.571 18.015 41.69 43.956 55.167 77.097l11.662 28.679 165.733-58.183-14.137-32.13c-26.688-60.655-64.896-108.61-114.191-144.011-49.329-35.423-117.458-54.302-204.859-54.302-50.78 0-95.646 7.376-134.767 21.542-40.093 14.671-74.09 34.79-102.239 60.259-28.84 26.207-50.646 57.06-65.496 92.701-14.718 35.052-22.101 72.538-22.101 112.401 0 72.536 20.667 133.294 61.165 182.704 38.624 47.255 98.346 88.037 179.861 121.291 42.257 17.475 78.715 33.125 109.227 46.994 27.193 12.361 49.294 26.124 66.157 41.751 15.309 14.186 26.497 30.584 33.63 49.258 7.721 20.214 11.16 45.69 11.16 76.402 0 28.021-4.251 51.787-13.591 71.219-8.832 18.374-20.171 33.178-34.523 44.219-14.787 11.374-31.193 19.591-49.393 24.466-19.68 5.359-39.14 7.993-58.69 7.993-29.359 0-54.387-3.407-75.182-10.747-20.112-7.013-37.144-16.144-51.259-27.486-13.618-11.009-24.971-23.766-33.744-38.279-9.64-15.8-17.272-31.924-23.032-48.408l-10.965-31.376-161.669 60.585 10.734 30.124c10.191 28.601 24.197 56.228 42.059 82.748 18.208 27.144 41.322 51.369 69.525 72.745 27.695 21.075 60.904 38.218 99.481 51.041 37.777 12.664 82.004 19.159 132.552 19.159 49.998 0 95.818-8.321 137.611-24.622 42.228-16.471 78.436-38.992 108.835-67.291 30.719-28.597 54.631-62.103 71.834-100.642 17.263-38.56 25.923-79.392 25.923-122.248 0-54.339-8.368-100.37-24.208-138.32-16.29-38.759-38.252-71.661-65.948-98.797-26.965-26.418-58.269-48.835-93.858-67.175-33.655-17.241-69.196-33.11-106.593-47.533-35.934-13.429-65.822-26.601-89.948-39.525-22.153-11.868-40.009-24.21-53.547-37.309-11.429-11.13-19.83-23.678-24.718-37.664-5.413-15.49-7.98-33.423-7.98-53.577 0-40.883 11.293-71.522 37.086-90.539 28.443-20.825 64.985-30.658 109.311-30.658z' fill='%23f1c40f' fill-rule='nonzero'/%3E%3Cpath d='M720 0h18v113h-18zM1458 738v-18h-113v18h113zM720 1345h18v113h-18zM113 738v-18H0v18h113z'/%3E%3C/g%3E%3C/svg%3E"},"dependencies":{"@stryker-mutator/jest-runner":"5.6.1","@stryker-mutator/typescript-checker":"5.6.1","jest":"26.6.3","typescript":"4.5.5","ts-jest":"26.5.6"}}}